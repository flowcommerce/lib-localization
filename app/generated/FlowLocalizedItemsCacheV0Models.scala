/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.3.60
 * apibuilder:0.12.38 https://app.apibuilder.io/flow/localized-items-cache/0.3.60/play_2_x_json
 */
package io.flow.localized.items.cache.v0.models {

  /**
   * @param currency ISO 4217 3 currency code as defined in
   * https://api.flow.io/reference/currencies
   * @param amount
   * @param label The localized label of the amount and currency
   */
  case class LocalizedItemCachePrice(
    currency: String,
    amount: BigDecimal,
    label: String
  )

  case class LocalizedItemCachePrices(
    local: io.flow.localized.items.cache.v0.models.LocalizedItemCachePrice,
    base: io.flow.localized.items.cache.v0.models.LocalizedItemCachePrice
  )

  /**
   * Pricing information of a localized item
   * @param price Contains the item price localized to a particular experience
   * @param includes
   * @param attributes Contains all attributes with intent price as keys of this map
   * - with each of those attributes mapped to its value in the local currency. For
   * example, if you have an attribute named 'msrp' and mark that attribute with
   * intent 'price', this map will have a key named 'msrp'
   */
  case class LocalizedItemCachePricing(
    price: io.flow.localized.items.cache.v0.models.LocalizedItemCachePrices,
    includes: _root_.scala.Option[io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey] = None,
    attributes: Map[String, io.flow.localized.items.cache.v0.models.LocalizedItemCachePrices]
  )

  /**
   * Represents an organization-specific currency conversion rate at a point in time.
   * @param base The base currency's ISO 4217 3-character code as defined in
   * https://api.flow.io/reference/currencies
   * @param effectiveAt The time at which this rate is effective.
   * @param id
   * @param target The target currency's ISO 4217 3-character code as defined in
   * https://api.flow.io/reference/currencies
   * @param value The actual conversion rate from the base currency to target
   * currency including any applicable margins.
   */
  case class LocalizedItemCacheRate(
    id: String,
    base: String,
    target: String,
    effectiveAt: _root_.org.joda.time.DateTime,
    value: BigDecimal
  )

  /**
   * Represents organization specific rates at a point in time
   */
  case class LocalizedItemCacheRates(
    rates: Seq[io.flow.localized.items.cache.v0.models.LocalizedItemCacheRate]
  )

  /**
   * Defines what components have been included in the price of a particular
   * localized item
   */
  sealed trait LocalizedItemCacheIncludedLevyKey extends _root_.scala.Product with _root_.scala.Serializable

  object LocalizedItemCacheIncludedLevyKey {

    case object Duty extends LocalizedItemCacheIncludedLevyKey { override def toString = "duty" }
    case object Vat extends LocalizedItemCacheIncludedLevyKey { override def toString = "vat" }
    case object VatAndDuty extends LocalizedItemCacheIncludedLevyKey { override def toString = "vat_and_duty" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends LocalizedItemCacheIncludedLevyKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Duty, Vat, VatAndDuty)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LocalizedItemCacheIncludedLevyKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LocalizedItemCacheIncludedLevyKey] = byName.get(value.toLowerCase)

  }

}

package io.flow.localized.items.cache.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.localized.items.cache.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsLocalizedItemsCacheLocalizedItemCacheIncludedLevyKey = new play.api.libs.json.Reads[io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesLocalizedItemsCacheLocalizedItemCacheIncludedLevyKey(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLocalizedItemCacheIncludedLevyKey(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemCacheIncludedLevyKey: play.api.libs.json.Writes[LocalizedItemCacheIncludedLevyKey] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey) = {
          jsonWritesLocalizedItemsCacheLocalizedItemCacheIncludedLevyKey(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedItemCachePrice: play.api.libs.json.Reads[LocalizedItemCachePrice] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "label").read[String]
      )(LocalizedItemCachePrice.apply _)
    }

    def jsObjectLocalizedItemCachePrice(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCachePrice): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemCachePrice: play.api.libs.json.Writes[LocalizedItemCachePrice] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemCachePrice] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCachePrice) = {
          jsObjectLocalizedItemCachePrice(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedItemCachePrices: play.api.libs.json.Reads[LocalizedItemCachePrices] = {
      (
        (__ \ "local").read[io.flow.localized.items.cache.v0.models.LocalizedItemCachePrice] and
        (__ \ "base").read[io.flow.localized.items.cache.v0.models.LocalizedItemCachePrice]
      )(LocalizedItemCachePrices.apply _)
    }

    def jsObjectLocalizedItemCachePrices(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCachePrices): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "local" -> jsObjectLocalizedItemCachePrice(obj.local),
        "base" -> jsObjectLocalizedItemCachePrice(obj.base)
      )
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemCachePrices: play.api.libs.json.Writes[LocalizedItemCachePrices] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemCachePrices] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCachePrices) = {
          jsObjectLocalizedItemCachePrices(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedItemCachePricing: play.api.libs.json.Reads[LocalizedItemCachePricing] = {
      (
        (__ \ "price").read[io.flow.localized.items.cache.v0.models.LocalizedItemCachePrices] and
        (__ \ "includes").readNullable[io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey] and
        (__ \ "attributes").read[Map[String, io.flow.localized.items.cache.v0.models.LocalizedItemCachePrices]]
      )(LocalizedItemCachePricing.apply _)
    }

    def jsObjectLocalizedItemCachePricing(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCachePricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price" -> jsObjectLocalizedItemCachePrices(obj.price),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.includes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("includes" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemCachePricing: play.api.libs.json.Writes[LocalizedItemCachePricing] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemCachePricing] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCachePricing) = {
          jsObjectLocalizedItemCachePricing(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedItemCacheRate: play.api.libs.json.Reads[LocalizedItemCacheRate] = {
      (
        (__ \ "id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "value").read[BigDecimal]
      )(LocalizedItemCacheRate.apply _)
    }

    def jsObjectLocalizedItemCacheRate(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCacheRate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt)),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemCacheRate: play.api.libs.json.Writes[LocalizedItemCacheRate] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemCacheRate] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCacheRate) = {
          jsObjectLocalizedItemCacheRate(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedItemCacheRates: play.api.libs.json.Reads[LocalizedItemCacheRates] = {
      (__ \ "rates").read[Seq[io.flow.localized.items.cache.v0.models.LocalizedItemCacheRate]].map { x => new LocalizedItemCacheRates(rates = x) }
    }

    def jsObjectLocalizedItemCacheRates(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCacheRates): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "rates" -> play.api.libs.json.Json.toJson(obj.rates)
      )
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemCacheRates: play.api.libs.json.Writes[LocalizedItemCacheRates] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemCacheRates] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemCacheRates) = {
          jsObjectLocalizedItemCacheRates(obj)
        }
      }
    }
  }
}

package io.flow.localized.items.cache.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}
    import org.joda.time.{DateTime, LocalDate}
    import org.joda.time.format.ISODateTimeFormat
    import io.flow.localized.items.cache.v0.models._

    // Type: date-time-iso8601
    implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    // Type: date-iso8601
    implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    // Enum: LocalizedItemCacheIncludedLevyKey
    private[this] val enumLocalizedItemCacheIncludedLevyKeyNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey.all.mkString(", ")}"

    implicit val pathBindableEnumLocalizedItemCacheIncludedLevyKey = new PathBindable.Parsing[io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey] (
      LocalizedItemCacheIncludedLevyKey.fromString(_).get, _.toString, enumLocalizedItemCacheIncludedLevyKeyNotFound
    )

    implicit val queryStringBindableEnumLocalizedItemCacheIncludedLevyKey = new QueryStringBindable.Parsing[io.flow.localized.items.cache.v0.models.LocalizedItemCacheIncludedLevyKey](
      LocalizedItemCacheIncludedLevyKey.fromString(_).get, _.toString, enumLocalizedItemCacheIncludedLevyKeyNotFound
    )

  }

}
