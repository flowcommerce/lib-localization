/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.3.59
 * apibuilder:0.12.38 https://app.apibuilder.io/flow/localized-items-cache/0.3.59/play_2_x_json
 */
package io.flow.localized.items.cache.v0.models {

  /**
   * @param currency ISO 4217 3 currency code as defined in
   * https://api.flow.io/reference/currencies
   * @param amount
   * @param label The localized label of the amount and currency
   */
  case class LocalizedItemPrice(
    currency: String,
    amount: BigDecimal,
    label: String
  )

  case class LocalizedItemPrices(
    local: io.flow.localized.items.cache.v0.models.LocalizedItemPrice,
    base: io.flow.localized.items.cache.v0.models.LocalizedItemPrice
  )

  /**
   * Pricing information of a localized item
   * @param price Contains the item price localized to a particular experience
   * @param includes
   * @param attributes Contains all attributes with intent price as keys of this map
   * - with each of those attributes mapped to its value in the local currency. For
   * example, if you have an attribute named 'msrp' and mark that attribute with
   * intent 'price', this map will have a key named 'msrp'
   */
  case class LocalizedPricing(
    price: io.flow.localized.items.cache.v0.models.LocalizedItemPrices,
    includes: _root_.scala.Option[io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey] = None,
    attributes: Map[String, io.flow.localized.items.cache.v0.models.LocalizedItemPrices]
  )

  /**
   * Defines what components have been included in the price of a particular
   * localized item
   */
  sealed trait LocalizedItemIncludedLevyKey extends _root_.scala.Product with _root_.scala.Serializable

  object LocalizedItemIncludedLevyKey {

    case object Duty extends LocalizedItemIncludedLevyKey { override def toString = "duty" }
    case object Vat extends LocalizedItemIncludedLevyKey { override def toString = "vat" }
    case object VatAndDuty extends LocalizedItemIncludedLevyKey { override def toString = "vat_and_duty" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends LocalizedItemIncludedLevyKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Duty, Vat, VatAndDuty)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LocalizedItemIncludedLevyKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LocalizedItemIncludedLevyKey] = byName.get(value.toLowerCase)

  }

}

package io.flow.localized.items.cache.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.localized.items.cache.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsLocalizedItemsCacheLocalizedItemIncludedLevyKey = new play.api.libs.json.Reads[io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesLocalizedItemsCacheLocalizedItemIncludedLevyKey(obj: io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLocalizedItemIncludedLevyKey(obj: io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemIncludedLevyKey: play.api.libs.json.Writes[LocalizedItemIncludedLevyKey] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey) = {
          jsonWritesLocalizedItemsCacheLocalizedItemIncludedLevyKey(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedItemPrice: play.api.libs.json.Reads[LocalizedItemPrice] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "label").read[String]
      )(LocalizedItemPrice.apply _)
    }

    def jsObjectLocalizedItemPrice(obj: io.flow.localized.items.cache.v0.models.LocalizedItemPrice): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemPrice: play.api.libs.json.Writes[LocalizedItemPrice] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemPrice] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemPrice) = {
          jsObjectLocalizedItemPrice(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedItemPrices: play.api.libs.json.Reads[LocalizedItemPrices] = {
      (
        (__ \ "local").read[io.flow.localized.items.cache.v0.models.LocalizedItemPrice] and
        (__ \ "base").read[io.flow.localized.items.cache.v0.models.LocalizedItemPrice]
      )(LocalizedItemPrices.apply _)
    }

    def jsObjectLocalizedItemPrices(obj: io.flow.localized.items.cache.v0.models.LocalizedItemPrices): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "local" -> jsObjectLocalizedItemPrice(obj.local),
        "base" -> jsObjectLocalizedItemPrice(obj.base)
      )
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedItemPrices: play.api.libs.json.Writes[LocalizedItemPrices] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedItemPrices] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedItemPrices) = {
          jsObjectLocalizedItemPrices(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedPricing: play.api.libs.json.Reads[LocalizedPricing] = {
      (
        (__ \ "price").read[io.flow.localized.items.cache.v0.models.LocalizedItemPrices] and
        (__ \ "includes").readNullable[io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey] and
        (__ \ "attributes").read[Map[String, io.flow.localized.items.cache.v0.models.LocalizedItemPrices]]
      )(LocalizedPricing.apply _)
    }

    def jsObjectLocalizedPricing(obj: io.flow.localized.items.cache.v0.models.LocalizedPricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price" -> jsObjectLocalizedItemPrices(obj.price),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.includes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("includes" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedPricing: play.api.libs.json.Writes[LocalizedPricing] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedPricing] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedPricing) = {
          jsObjectLocalizedPricing(obj)
        }
      }
    }
  }
}

package io.flow.localized.items.cache.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}
    import org.joda.time.{DateTime, LocalDate}
    import org.joda.time.format.ISODateTimeFormat
    import io.flow.localized.items.cache.v0.models._

    // Type: date-time-iso8601
    implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    // Type: date-iso8601
    implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    // Enum: LocalizedItemIncludedLevyKey
    private[this] val enumLocalizedItemIncludedLevyKeyNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey.all.mkString(", ")}"

    implicit val pathBindableEnumLocalizedItemIncludedLevyKey = new PathBindable.Parsing[io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey] (
      LocalizedItemIncludedLevyKey.fromString(_).get, _.toString, enumLocalizedItemIncludedLevyKeyNotFound
    )

    implicit val queryStringBindableEnumLocalizedItemIncludedLevyKey = new QueryStringBindable.Parsing[io.flow.localized.items.cache.v0.models.LocalizedItemIncludedLevyKey](
      LocalizedItemIncludedLevyKey.fromString(_).get, _.toString, enumLocalizedItemIncludedLevyKeyNotFound
    )

  }

}
