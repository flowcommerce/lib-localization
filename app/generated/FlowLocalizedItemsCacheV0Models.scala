/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.3.56
 * apibuilder:0.12.38 https://app.apibuilder.io/flow/localized-items-cache/0.3.56/play_2_x_json
 */
package io.flow.localized.items.cache.v0.models {

  /**
   * Represents a specific localized price
   */
  case class LocalizedCachePrice(
    key: String,
    price: io.flow.common.v0.models.PriceWithBase
  )

  /**
   * Pricing information of a localized item
   * @param prices
   * @param includes Description of what is included in the pricing
   */
  case class LocalizedPricing(
    prices: Seq[io.flow.localized.items.cache.v0.models.LocalizedCachePrice],
    includes: _root_.scala.Option[String] = None
  )

}

package io.flow.localized.items.cache.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.localized.items.cache.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedCachePrice: play.api.libs.json.Reads[LocalizedCachePrice] = {
      (
        (__ \ "key").read[String] and
        (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
      )(LocalizedCachePrice.apply _)
    }

    def jsObjectLocalizedCachePrice(obj: io.flow.localized.items.cache.v0.models.LocalizedCachePrice): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price)
      )
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedCachePrice: play.api.libs.json.Writes[LocalizedCachePrice] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedCachePrice] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedCachePrice) = {
          jsObjectLocalizedCachePrice(obj)
        }
      }
    }

    implicit def jsonReadsLocalizedItemsCacheLocalizedPricing: play.api.libs.json.Reads[LocalizedPricing] = {
      (
        (__ \ "prices").read[Seq[io.flow.localized.items.cache.v0.models.LocalizedCachePrice]] and
        (__ \ "includes").readNullable[String]
      )(LocalizedPricing.apply _)
    }

    def jsObjectLocalizedPricing(obj: io.flow.localized.items.cache.v0.models.LocalizedPricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prices" -> play.api.libs.json.Json.toJson(obj.prices)
      ) ++ (obj.includes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("includes" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesLocalizedItemsCacheLocalizedPricing: play.api.libs.json.Writes[LocalizedPricing] = {
      new play.api.libs.json.Writes[io.flow.localized.items.cache.v0.models.LocalizedPricing] {
        def writes(obj: io.flow.localized.items.cache.v0.models.LocalizedPricing) = {
          jsObjectLocalizedPricing(obj)
        }
      }
    }
  }
}

package io.flow.localized.items.cache.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}
    import org.joda.time.{DateTime, LocalDate}
    import org.joda.time.format.ISODateTimeFormat
    import io.flow.localized.items.cache.v0.models._

    // Type: date-time-iso8601
    implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    // Type: date-iso8601
    implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )



  }

}
