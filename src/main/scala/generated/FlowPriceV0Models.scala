/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.3.47
 * apibuilder:0.12.38 https://app.apibuilder.io/flow/price/0.3.47/play_2_x_standalone_json
 */
package io.flow.price.v0.models {

  /**
   * De Minimis describes the country specific rules for exactly how tax and duties
   * are calculated, as well as any exemptions that apply. See
   * https://en.wikipedia.org/wiki/De_minimis for more information.
   */
  sealed trait Deminimis extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Deminimis
   */
  sealed trait DeminimisDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object DeminimisDiscriminator {

    case object DeminimisSimple extends DeminimisDiscriminator { override def toString = "deminimis_simple" }
    case object DeminimisPerItem extends DeminimisDiscriminator { override def toString = "deminimis_per_item" }

    case class UNDEFINED(override val toString: String) extends DeminimisDiscriminator

    val all: List[DeminimisDiscriminator] = List(DeminimisSimple, DeminimisPerItem)

    private[this] val byName: Map[String, DeminimisDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeminimisDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeminimisDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * De Minimis per item describes rules which require minimum and/or maximum values
   * per item
   * @param currency The ISO-4217 3 character currency code in which the value is
   * calculated
   * @param minimum If specified, the minimum amount due per item
   * @param maximum If specified, the maximum amount due per item
   */
  case class DeminimisPerItem(
    currency: String,
    minimum: _root_.scala.Option[BigDecimal] = None,
    maximum: _root_.scala.Option[BigDecimal] = None
  ) extends Deminimis

  /**
   * De Minimis for most common example which includes a value threshold and rules on
   * what components are used in the duty calculation
   * @param value The value below which no tax or duty is collected, which is a sum
   * of the values associated with the de minimis components.
   * @param currency The ISO-4217 3 character currency code in which the value is
   * calculated.
   * @param components The components that are used to determine the value. Note that
   * these components may be different from the components for the VAT or duty
   * itself.
   * @param minimum If the calculated VAT or duty amount is less than the minimum, no
   * VAT or duty is owed. In other words, this is the minimum payable amount.
   */
  case class DeminimisSimple(
    value: _root_.scala.Option[BigDecimal] = None,
    currency: String,
    components: Seq[io.flow.price.v0.models.LevyComponent],
    minimum: _root_.scala.Option[BigDecimal] = None
  ) extends Deminimis

  /**
   * Represents a simple model of duties that apply to a given item / trade lane.
   * @param rate The combined duty rate. A value of 25 indicates a duty rate of 25%
   * @param components The components to which duty is applied.
   * @param deminimis Describes the duty de minimis if there is one for this
   * destination
   */
  case class Duty(
    rate: BigDecimal,
    components: Seq[io.flow.price.v0.models.LevyComponent],
    deminimis: _root_.scala.Option[io.flow.price.v0.models.Deminimis] = None
  )

  /**
   * @param base Contains the localized price details, but converted to the base
   * currency of the organization.
   * @param local Contains the localized price details in the currency of the
   * experience.
   * @param discount Contains the amount subtracted post-VAT/Duty/Rounding due to a
   * percent discount.
   * @param localBeforeDiscount Contains the amount subtracted post-VAT/Duty/Rounding
   * due to a percent discount.
   */
  case class LocalPriceDetails(
    base: io.flow.price.v0.models.PriceDetails,
    local: io.flow.price.v0.models.PriceDetails,
    discount: _root_.scala.Option[io.flow.price.v0.models.PriceDetail] = None,
    localBeforeDiscount: _root_.scala.Option[io.flow.price.v0.models.PriceDetail] = None
  )

  /**
   * @param display Contains the (estimated) price details that are displayed to the
   * user. These details will never change.
   * @param `final` Contains the final price details, which are initially equal to
   * the display details. At the order level (when shipping address is known), these
   * details may be adjusted.
   */
  case class PriceCheck(
    display: io.flow.price.v0.models.LocalPriceDetails,
    `final`: io.flow.price.v0.models.LocalPriceDetails
  )

  /**
   * Represents a top-level price detail, e.g. 'Subtotal' or 'VAT'.
   * @param name The display name for this price detail.
   * @param label The formatted label to display for this detail, e.g. '$123.45 CAD'.
   * @param components
   * @param amount
   * @param key The key indicating what this price detail represents.
   */
  case class PriceDetail(
    key: io.flow.price.v0.models.PriceDetailKey,
    components: Seq[io.flow.price.v0.models.PriceDetailComponent],
    amount: BigDecimal,
    label: String,
    name: _root_.scala.Option[String] = None
  )

  /**
   * @param key
   * @param amount
   * @param label The formatted label to display for this component, e.g. '$123.45
   * CAD'.
   * @param name The display name for this price detail component.
   */
  case class PriceDetailComponent(
    key: io.flow.price.v0.models.PriceDetailComponentKey,
    amount: BigDecimal,
    label: String,
    name: _root_.scala.Option[String] = None
  )

  /**
   * Detailed information for the pricing of a given item within an experience.
   * @param rounding The amount required to meet the rounding requirements from the
   * experience's settings. For example, if an item price is 121.50, and the rounding
   * setting is up to the nearest '1.00', rounding would return .50 here.
   * @param vat The total amount of VAT applied. VAT is applied to the item price and
   * optionally to the duty/shipping prices based on the destination country.
   * @param duty The total amount of DUTY applied. Duty is applied to the item price
   * and optionally to the shipping prices based on the destination country, and also
   * will take into account de minimis (thus amount may be zero if de minimis
   * applies).
   * @param margins Contains the currency margin, percent item margin, and fixed item
   * margin.
   * @param price The rounded price of the item as seen by customers in price detail
   * pages, which takes into account VAT and duty pricing settings of the experience.
   * @param adjustment The total amount the total price was altered due to sales
   * margins. A negative value indicates a discount.
   * @param total The total price of the item as seen by customers at checkout, which
   * includes the base price, discount, margins, VAT, duty, and rounding.
   * @param itemPrice Details of the item's base price from the master catalog,
   * including any applicable discounts.
   * @param currency The currency in which these price details were calculated.
   */
  case class PriceDetails(
    currency: String,
    itemPrice: io.flow.price.v0.models.PriceDetail,
    margins: io.flow.price.v0.models.PriceDetail,
    vat: io.flow.price.v0.models.PriceDetail,
    duty: io.flow.price.v0.models.PriceDetail,
    rounding: io.flow.price.v0.models.PriceDetail,
    price: io.flow.common.v0.models.Price,
    total: io.flow.common.v0.models.Price,
    adjustment: _root_.scala.Option[io.flow.price.v0.models.PriceDetail] = None
  )

  /**
   * @param rate The value of the currency conversion rate that includes an
   * organization-specific margin if applicable.
   * @param contractedRate The value of the contracted currency conversion rate
   * between Flow and an organization.
   * @param duty The duty rate applicable to the product. A value of 15 indicates a
   * duty rate of 15%.
   * @param fixedMargin A fixed amount to add, e.g 2.5 would add an absolute margin
   * of 2.5 in the base currency of your item.
   * @param insurance The insurance information associated with the product.
   * @param tax The tax rate applicable to the product. A value of 17 indicates a tax
   * rate of 17%.
   * @param percentMargin A percent of the base cost to add, e.g. 1.2 would represent
   * a 1.2% increase.
   * @param freight The freight information associated with the product.
   * @param basePrice The base price of the product.
   * @param percentSalesMargin A percent sales margin to apply after the other
   * margins, duties, taxes and margins. A value of 17 indicates an increase of 17%.
   * A value of 5.5 indicates a discount of 5.5%
   * @param discount The discount to apply to the base price of the product in the
   * same currency as the base product.
   * @param pricing Contains pricing settings for VAT, duty, and rounding.
   */
  case class PriceEquation(
    contractedRate: BigDecimal,
    rate: BigDecimal,
    pricing: io.flow.price.v0.models.Pricing,
    basePrice: BigDecimal,
    discount: BigDecimal,
    fixedMargin: BigDecimal,
    percentMargin: BigDecimal,
    insurance: BigDecimal,
    freight: BigDecimal,
    duty: _root_.scala.Option[io.flow.price.v0.models.Duty] = None,
    tax: _root_.scala.Option[io.flow.price.v0.models.Tax] = None,
    percentSalesMargin: BigDecimal = 0
  )

  /**
   * Pricing determines how the item price is calculated when items are requests via
   * the experience.
   * @param vat Determines how VAT is treated within this experience - whether it is
   * included in the item price, displayed as a stand alone line item, or ignored -
   * and only used in checkout (see the orders resource)
   * @param duty Determines how Duty is treated within this experience - whether it
   * is included in the item price, displayed as a stand alone line item, or ignored
   * - and only used in checkout (see the orders resource)
   * @param rounding If specified, we will round prices in this experience
   */
  case class Pricing(
    vat: io.flow.price.v0.models.PricingLevySetting,
    duty: io.flow.price.v0.models.PricingLevySetting,
    rounding: _root_.scala.Option[io.flow.common.v0.models.Rounding] = None
  )

  /**
   * Represents a simple model of taxes that apply to a given item / destination.
   * @param name The name of the taxes being applied
   * @param rate The combined tax rate. A value of 17 indicates a tax rate of 17%
   * @param components The components to which tax is applied.
   * @param deminimis Describes the tax de minimis if there is one for this
   * destination
   */
  case class Tax(
    name: String,
    rate: BigDecimal,
    components: Seq[io.flow.price.v0.models.LevyComponent],
    deminimis: _root_.scala.Option[io.flow.price.v0.models.Deminimis] = None
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Deminimis, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * @param description Information about the type that we received that is undefined
   * in this version of the client.
   */
  case class DeminimisUndefinedType(
    description: String
  ) extends Deminimis

  sealed trait LevyComponent extends _root_.scala.Product with _root_.scala.Serializable

  object LevyComponent {

    /**
     * The value of goods
     */
    case object Goods extends LevyComponent { override def toString = "goods" }
    case object Duty extends LevyComponent { override def toString = "duty" }
    case object Insurance extends LevyComponent { override def toString = "insurance" }
    case object Freight extends LevyComponent { override def toString = "freight" }
    /**
     * Value-Added Tax
     */
    case object Vat extends LevyComponent { override def toString = "vat" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends LevyComponent

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: List[LevyComponent] = List(Goods, Duty, Insurance, Freight, Vat)

    private[this]
    val byName: Map[String, LevyComponent] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LevyComponent = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LevyComponent] = byName.get(value.toLowerCase)

  }

  sealed trait LevyStrategy extends _root_.scala.Product with _root_.scala.Serializable

  object LevyStrategy {

    case object Minimum extends LevyStrategy { override def toString = "minimum" }
    case object Average extends LevyStrategy { override def toString = "average" }
    case object Maximum extends LevyStrategy { override def toString = "maximum" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends LevyStrategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: List[LevyStrategy] = List(Minimum, Average, Maximum)

    private[this]
    val byName: Map[String, LevyStrategy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LevyStrategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LevyStrategy] = byName.get(value.toLowerCase)

  }

  sealed trait PriceDetailComponentKey extends _root_.scala.Product with _root_.scala.Serializable

  object PriceDetailComponentKey {

    /**
     * The base price of the item.
     */
    case object BasePrice extends PriceDetailComponentKey { override def toString = "base_price" }
    /**
     * A discount applied to the base price of the item.
     */
    case object Discount extends PriceDetailComponentKey { override def toString = "discount" }
    /**
     * The amount added to the post-discount item price due to FX markup, as configured
     * in the organization's currency settings.
     */
    case object CurrencyMargin extends PriceDetailComponentKey { override def toString = "currency_margin" }
    /**
     * The amount added to the post-discount item price from a percent item margin.
     * Negative amounts represent discounts.
     */
    case object PercentItemMargin extends PriceDetailComponentKey { override def toString = "percent_item_margin" }
    /**
     * The amount added to the post-discount item price from a fixed item margin.
     * Negative amounts represent discounts.
     */
    case object FixedItemMargin extends PriceDetailComponentKey { override def toString = "fixed_item_margin" }
    /**
     * The duty owed on the post-discount base item price.
     */
    case object DutiesItemPrice extends PriceDetailComponentKey { override def toString = "duties_item_price" }
    /**
     * The duty owed on the sum of the currency margin, percent item margin, and fixed
     * item margin.
     */
    case object DutiesAddedMargin extends PriceDetailComponentKey { override def toString = "duties_added_margin" }
    /**
     * The duty owed on any rounding applied to the total item price.
     */
    case object DutiesRounding extends PriceDetailComponentKey { override def toString = "duties_rounding" }
    /**
     * An adjustment made if the item does not meet the duty de minimis rule.
     */
    case object DutiesDeminimis extends PriceDetailComponentKey { override def toString = "duties_deminimis" }
    /**
     * The VAT owed on the post-discount base item price.
     */
    case object VatItemPrice extends PriceDetailComponentKey { override def toString = "vat_item_price" }
    /**
     * The VAT owed on the sum of the currency margin, percent item margin, and fixed
     * item margin.
     */
    case object VatAddedMargin extends PriceDetailComponentKey { override def toString = "vat_added_margin" }
    /**
     * The VAT owed on any rounding applied to the total item price.
     */
    case object VatRounding extends PriceDetailComponentKey { override def toString = "vat_rounding" }
    /**
     * The VAT owed on the duty owed on the post-discount base item price.
     */
    case object VatDutiesItemPrice extends PriceDetailComponentKey { override def toString = "vat_duties_item_price" }
    /**
     * The VAT owed on the duty owed on the sum of the currency margin, percent item
     * margin, and fixed item margin.
     */
    case object VatDutiesAddedMargin extends PriceDetailComponentKey { override def toString = "vat_duties_added_margin" }
    /**
     * The VAT owed on the duty owed on any rounding applied to the total item price.
     */
    case object VatDutiesRounding extends PriceDetailComponentKey { override def toString = "vat_duties_rounding" }
    /**
     * An adjustment made if the item does not meet the VAT de minimis rule.
     */
    case object VatDeminimis extends PriceDetailComponentKey { override def toString = "vat_deminimis" }
    /**
     * An adjustment made to the item price as a result of a percent sales margin.
     */
    case object ItemPricePercentSalesMargin extends PriceDetailComponentKey { override def toString = "item_price_percent_sales_margin" }
    /**
     * An adjustment made to the item margins as a result of a percent sales margin.
     */
    case object MarginsPercentSalesMargin extends PriceDetailComponentKey { override def toString = "margins_percent_sales_margin" }
    /**
     * An adjustment made to rounding as a result of a percent sales margin.
     */
    case object RoundingPercentSalesMargin extends PriceDetailComponentKey { override def toString = "rounding_percent_sales_margin" }
    /**
     * An adjustment made to VAT owed as a result of a percent sales margin.
     */
    case object VatPercentSalesMargin extends PriceDetailComponentKey { override def toString = "vat_percent_sales_margin" }
    /**
     * An adjustment made to VAT on duties (e.g. VAT on duties on item price) owed as a
     * result of a percent sales margin.
     */
    case object VatDutyPercentSalesMargin extends PriceDetailComponentKey { override def toString = "vat_duty_percent_sales_margin" }
    /**
     * An adjustment made to duty owed as a result of a percent sales margin.
     */
    case object DutyPercentSalesMargin extends PriceDetailComponentKey { override def toString = "duty_percent_sales_margin" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends PriceDetailComponentKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: List[PriceDetailComponentKey] = List(BasePrice, Discount, CurrencyMargin, PercentItemMargin, FixedItemMargin, DutiesItemPrice, DutiesAddedMargin, DutiesRounding, DutiesDeminimis, VatItemPrice, VatAddedMargin, VatRounding, VatDutiesItemPrice, VatDutiesAddedMargin, VatDutiesRounding, VatDeminimis, ItemPricePercentSalesMargin, MarginsPercentSalesMargin, RoundingPercentSalesMargin, VatPercentSalesMargin, VatDutyPercentSalesMargin, DutyPercentSalesMargin)

    private[this]
    val byName: Map[String, PriceDetailComponentKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceDetailComponentKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceDetailComponentKey] = byName.get(value.toLowerCase)

  }

  sealed trait PriceDetailKey extends _root_.scala.Product with _root_.scala.Serializable

  object PriceDetailKey {

    /**
     * The details of the item price.
     */
    case object ItemPrice extends PriceDetailKey { override def toString = "item_price" }
    /**
     * The details of any margins added to the item price.
     */
    case object Margins extends PriceDetailKey { override def toString = "margins" }
    /**
     * The details of any VAT owed on the item.
     */
    case object Vat extends PriceDetailKey { override def toString = "vat" }
    /**
     * The details of any duties owed on the item.
     */
    case object Duty extends PriceDetailKey { override def toString = "duty" }
    /**
     * The details of any rounding added to the item.
     */
    case object Rounding extends PriceDetailKey { override def toString = "rounding" }
    /**
     * The details of any price adjustments due to sales margins. A negative value
     * indicates a discount.
     */
    case object Adjustment extends PriceDetailKey { override def toString = "adjustment" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends PriceDetailKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: List[PriceDetailKey] = List(ItemPrice, Margins, Vat, Duty, Rounding, Adjustment)

    private[this]
    val byName: Map[String, PriceDetailKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceDetailKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceDetailKey] = byName.get(value.toLowerCase)

  }

  sealed trait PricingLevySetting extends _root_.scala.Product with _root_.scala.Serializable

  object PricingLevySetting {

    case object Included extends PricingLevySetting { override def toString = "included" }
    case object Displayed extends PricingLevySetting { override def toString = "displayed" }
    case object Ignored extends PricingLevySetting { override def toString = "ignored" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends PricingLevySetting

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: List[PricingLevySetting] = List(Included, Displayed, Ignored)

    private[this]
    val byName: Map[String, PricingLevySetting] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PricingLevySetting = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PricingLevySetting] = byName.get(value.toLowerCase)

  }

}

package io.flow.price.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.price.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsPriceLevyComponent = new play.api.libs.json.Reads[io.flow.price.v0.models.LevyComponent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.LevyComponent] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyComponent(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyComponent(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPriceLevyComponent(obj: io.flow.price.v0.models.LevyComponent) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLevyComponent(obj: io.flow.price.v0.models.LevyComponent) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPriceLevyComponent: play.api.libs.json.Writes[LevyComponent] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.LevyComponent] {
        def writes(obj: io.flow.price.v0.models.LevyComponent) = {
          jsonWritesPriceLevyComponent(obj)
        }
      }
    }

    implicit val jsonReadsPriceLevyStrategy = new play.api.libs.json.Reads[io.flow.price.v0.models.LevyStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.LevyStrategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyStrategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyStrategy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPriceLevyStrategy(obj: io.flow.price.v0.models.LevyStrategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLevyStrategy(obj: io.flow.price.v0.models.LevyStrategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPriceLevyStrategy: play.api.libs.json.Writes[LevyStrategy] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.LevyStrategy] {
        def writes(obj: io.flow.price.v0.models.LevyStrategy) = {
          jsonWritesPriceLevyStrategy(obj)
        }
      }
    }

    implicit val jsonReadsPricePriceDetailComponentKey = new play.api.libs.json.Reads[io.flow.price.v0.models.PriceDetailComponentKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.PriceDetailComponentKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailComponentKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailComponentKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPricePriceDetailComponentKey(obj: io.flow.price.v0.models.PriceDetailComponentKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPriceDetailComponentKey(obj: io.flow.price.v0.models.PriceDetailComponentKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPricePriceDetailComponentKey: play.api.libs.json.Writes[PriceDetailComponentKey] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetailComponentKey] {
        def writes(obj: io.flow.price.v0.models.PriceDetailComponentKey) = {
          jsonWritesPricePriceDetailComponentKey(obj)
        }
      }
    }

    implicit val jsonReadsPricePriceDetailKey = new play.api.libs.json.Reads[io.flow.price.v0.models.PriceDetailKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.PriceDetailKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPricePriceDetailKey(obj: io.flow.price.v0.models.PriceDetailKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPriceDetailKey(obj: io.flow.price.v0.models.PriceDetailKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPricePriceDetailKey: play.api.libs.json.Writes[PriceDetailKey] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetailKey] {
        def writes(obj: io.flow.price.v0.models.PriceDetailKey) = {
          jsonWritesPricePriceDetailKey(obj)
        }
      }
    }

    implicit val jsonReadsPricePricingLevySetting = new play.api.libs.json.Reads[io.flow.price.v0.models.PricingLevySetting] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.PricingLevySetting] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PricingLevySetting(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PricingLevySetting(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPricePricingLevySetting(obj: io.flow.price.v0.models.PricingLevySetting) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPricingLevySetting(obj: io.flow.price.v0.models.PricingLevySetting) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPricePricingLevySetting: play.api.libs.json.Writes[PricingLevySetting] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PricingLevySetting] {
        def writes(obj: io.flow.price.v0.models.PricingLevySetting) = {
          jsonWritesPricePricingLevySetting(obj)
        }
      }
    }

    implicit def jsonReadsPriceDeminimisPerItem: play.api.libs.json.Reads[DeminimisPerItem] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "minimum").readNullable[BigDecimal] and
        (__ \ "maximum").readNullable[BigDecimal]
      )(DeminimisPerItem.apply _)
    }

    def jsObjectDeminimisPerItem(obj: io.flow.price.v0.models.DeminimisPerItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.minimum match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("minimum" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.maximum match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("maximum" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonReadsPriceDeminimisSimple: play.api.libs.json.Reads[DeminimisSimple] = {
      (
        (__ \ "value").readNullable[BigDecimal] and
        (__ \ "currency").read[String] and
        (__ \ "components").read[Seq[io.flow.price.v0.models.LevyComponent]] and
        (__ \ "minimum").readNullable[BigDecimal]
      )(DeminimisSimple.apply _)
    }

    def jsObjectDeminimisSimple(obj: io.flow.price.v0.models.DeminimisSimple): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.value match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.minimum match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("minimum" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonReadsPriceDuty: play.api.libs.json.Reads[Duty] = {
      (
        (__ \ "rate").read[BigDecimal] and
        (__ \ "components").read[Seq[io.flow.price.v0.models.LevyComponent]] and
        (__ \ "deminimis").readNullable[io.flow.price.v0.models.Deminimis]
      )(Duty.apply _)
    }

    def jsObjectDuty(obj: io.flow.price.v0.models.Duty): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.deminimis match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("deminimis" -> jsObjectDeminimis(x))
      })
    }

    implicit def jsonWritesPriceDuty: play.api.libs.json.Writes[Duty] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Duty] {
        def writes(obj: io.flow.price.v0.models.Duty) = {
          jsObjectDuty(obj)
        }
      }
    }

    implicit def jsonReadsPriceLocalPriceDetails: play.api.libs.json.Reads[LocalPriceDetails] = {
      (
        (__ \ "base").read[io.flow.price.v0.models.PriceDetails] and
        (__ \ "local").read[io.flow.price.v0.models.PriceDetails] and
        (__ \ "discount").readNullable[io.flow.price.v0.models.PriceDetail] and
        (__ \ "local_before_discount").readNullable[io.flow.price.v0.models.PriceDetail]
      )(LocalPriceDetails.apply _)
    }

    def jsObjectLocalPriceDetails(obj: io.flow.price.v0.models.LocalPriceDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "base" -> jsObjectPriceDetails(obj.base),
        "local" -> jsObjectPriceDetails(obj.local)
      ) ++ (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectPriceDetail(x))
      }) ++
      (obj.localBeforeDiscount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("local_before_discount" -> jsObjectPriceDetail(x))
      })
    }

    implicit def jsonWritesPriceLocalPriceDetails: play.api.libs.json.Writes[LocalPriceDetails] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.LocalPriceDetails] {
        def writes(obj: io.flow.price.v0.models.LocalPriceDetails) = {
          jsObjectLocalPriceDetails(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceCheck: play.api.libs.json.Reads[PriceCheck] = {
      (
        (__ \ "display").read[io.flow.price.v0.models.LocalPriceDetails] and
        (__ \ "final").read[io.flow.price.v0.models.LocalPriceDetails]
      )(PriceCheck.apply _)
    }

    def jsObjectPriceCheck(obj: io.flow.price.v0.models.PriceCheck): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "display" -> jsObjectLocalPriceDetails(obj.display),
        "final" -> jsObjectLocalPriceDetails(obj.`final`)
      )
    }

    implicit def jsonWritesPricePriceCheck: play.api.libs.json.Writes[PriceCheck] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceCheck] {
        def writes(obj: io.flow.price.v0.models.PriceCheck) = {
          jsObjectPriceCheck(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceDetail: play.api.libs.json.Reads[PriceDetail] = {
      (
        (__ \ "key").read[io.flow.price.v0.models.PriceDetailKey] and
        (__ \ "components").read[Seq[io.flow.price.v0.models.PriceDetailComponent]] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "label").read[String] and
        (__ \ "name").readNullable[String]
      )(PriceDetail.apply _)
    }

    def jsObjectPriceDetail(obj: io.flow.price.v0.models.PriceDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "components" -> play.api.libs.json.Json.toJson(obj.components),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPricePriceDetail: play.api.libs.json.Writes[PriceDetail] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetail] {
        def writes(obj: io.flow.price.v0.models.PriceDetail) = {
          jsObjectPriceDetail(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceDetailComponent: play.api.libs.json.Reads[PriceDetailComponent] = {
      (
        (__ \ "key").read[io.flow.price.v0.models.PriceDetailComponentKey] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "label").read[String] and
        (__ \ "name").readNullable[String]
      )(PriceDetailComponent.apply _)
    }

    def jsObjectPriceDetailComponent(obj: io.flow.price.v0.models.PriceDetailComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPricePriceDetailComponent: play.api.libs.json.Writes[PriceDetailComponent] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetailComponent] {
        def writes(obj: io.flow.price.v0.models.PriceDetailComponent) = {
          jsObjectPriceDetailComponent(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceDetails: play.api.libs.json.Reads[PriceDetails] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "item_price").read[io.flow.price.v0.models.PriceDetail] and
        (__ \ "margins").read[io.flow.price.v0.models.PriceDetail] and
        (__ \ "vat").read[io.flow.price.v0.models.PriceDetail] and
        (__ \ "duty").read[io.flow.price.v0.models.PriceDetail] and
        (__ \ "rounding").read[io.flow.price.v0.models.PriceDetail] and
        (__ \ "price").read[io.flow.common.v0.models.Price] and
        (__ \ "total").read[io.flow.common.v0.models.Price] and
        (__ \ "adjustment").readNullable[io.flow.price.v0.models.PriceDetail]
      )(PriceDetails.apply _)
    }

    def jsObjectPriceDetails(obj: io.flow.price.v0.models.PriceDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "item_price" -> jsObjectPriceDetail(obj.itemPrice),
        "margins" -> jsObjectPriceDetail(obj.margins),
        "vat" -> jsObjectPriceDetail(obj.vat),
        "duty" -> jsObjectPriceDetail(obj.duty),
        "rounding" -> jsObjectPriceDetail(obj.rounding),
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPrice(obj.total)
      ) ++ (obj.adjustment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjustment" -> jsObjectPriceDetail(x))
      })
    }

    implicit def jsonWritesPricePriceDetails: play.api.libs.json.Writes[PriceDetails] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetails] {
        def writes(obj: io.flow.price.v0.models.PriceDetails) = {
          jsObjectPriceDetails(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceEquation: play.api.libs.json.Reads[PriceEquation] = {
      (
        (__ \ "contracted_rate").read[BigDecimal] and
        (__ \ "rate").read[BigDecimal] and
        (__ \ "pricing").read[io.flow.price.v0.models.Pricing] and
        (__ \ "base_price").read[BigDecimal] and
        (__ \ "discount").read[BigDecimal] and
        (__ \ "fixed_margin").read[BigDecimal] and
        (__ \ "percent_margin").read[BigDecimal] and
        (__ \ "insurance").read[BigDecimal] and
        (__ \ "freight").read[BigDecimal] and
        (__ \ "duty").readNullable[io.flow.price.v0.models.Duty] and
        (__ \ "tax").readNullable[io.flow.price.v0.models.Tax] and
        (__ \ "percent_sales_margin").read[BigDecimal]
      )(PriceEquation.apply _)
    }

    def jsObjectPriceEquation(obj: io.flow.price.v0.models.PriceEquation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "contracted_rate" -> play.api.libs.json.JsNumber(obj.contractedRate),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "pricing" -> jsObjectPricing(obj.pricing),
        "base_price" -> play.api.libs.json.JsNumber(obj.basePrice),
        "discount" -> play.api.libs.json.JsNumber(obj.discount),
        "fixed_margin" -> play.api.libs.json.JsNumber(obj.fixedMargin),
        "percent_margin" -> play.api.libs.json.JsNumber(obj.percentMargin),
        "insurance" -> play.api.libs.json.JsNumber(obj.insurance),
        "freight" -> play.api.libs.json.JsNumber(obj.freight),
        "percent_sales_margin" -> play.api.libs.json.JsNumber(obj.percentSalesMargin)
      ) ++ (obj.duty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty" -> jsObjectDuty(x))
      }) ++
      (obj.tax match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax" -> jsObjectTax(x))
      })
    }

    implicit def jsonWritesPricePriceEquation: play.api.libs.json.Writes[PriceEquation] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceEquation] {
        def writes(obj: io.flow.price.v0.models.PriceEquation) = {
          jsObjectPriceEquation(obj)
        }
      }
    }

    implicit def jsonReadsPricePricing: play.api.libs.json.Reads[Pricing] = {
      (
        (__ \ "vat").read[io.flow.price.v0.models.PricingLevySetting] and
        (__ \ "duty").read[io.flow.price.v0.models.PricingLevySetting] and
        (__ \ "rounding").readNullable[io.flow.common.v0.models.Rounding]
      )(Pricing.apply _)
    }

    def jsObjectPricing(obj: io.flow.price.v0.models.Pricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "vat" -> play.api.libs.json.JsString(obj.vat.toString),
        "duty" -> play.api.libs.json.JsString(obj.duty.toString)
      ) ++ (obj.rounding match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rounding" -> io.flow.common.v0.models.json.jsObjectRounding(x))
      })
    }

    implicit def jsonWritesPricePricing: play.api.libs.json.Writes[Pricing] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Pricing] {
        def writes(obj: io.flow.price.v0.models.Pricing) = {
          jsObjectPricing(obj)
        }
      }
    }

    implicit def jsonReadsPriceTax: play.api.libs.json.Reads[Tax] = {
      (
        (__ \ "name").read[String] and
        (__ \ "rate").read[BigDecimal] and
        (__ \ "components").read[Seq[io.flow.price.v0.models.LevyComponent]] and
        (__ \ "deminimis").readNullable[io.flow.price.v0.models.Deminimis]
      )(Tax.apply _)
    }

    def jsObjectTax(obj: io.flow.price.v0.models.Tax): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.deminimis match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("deminimis" -> jsObjectDeminimis(x))
      })
    }

    implicit def jsonWritesPriceTax: play.api.libs.json.Writes[Tax] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Tax] {
        def writes(obj: io.flow.price.v0.models.Tax) = {
          jsObjectTax(obj)
        }
      }
    }

    implicit def jsonReadsPriceDeminimis: play.api.libs.json.Reads[Deminimis] = new play.api.libs.json.Reads[Deminimis] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Deminimis] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[Deminimis] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "deminimis_simple" => js.validate[io.flow.price.v0.models.DeminimisSimple]
          case "deminimis_per_item" => js.validate[io.flow.price.v0.models.DeminimisPerItem]
          case other => play.api.libs.json.JsSuccess(io.flow.price.v0.models.DeminimisUndefinedType(other))
        }
      }
    }

    def jsObjectDeminimis(obj: io.flow.price.v0.models.Deminimis): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.price.v0.models.DeminimisSimple => jsObjectDeminimisSimple(x) ++ play.api.libs.json.Json.obj("discriminator" -> "deminimis_simple")
        case x: io.flow.price.v0.models.DeminimisPerItem => jsObjectDeminimisPerItem(x) ++ play.api.libs.json.Json.obj("discriminator" -> "deminimis_per_item")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPriceDeminimis: play.api.libs.json.Writes[Deminimis] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Deminimis] {
        def writes(obj: io.flow.price.v0.models.Deminimis) = {
          jsObjectDeminimis(obj)
        }
      }
    }
  }
}

