/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.3.56
 * apibuilder:0.12.38 https://app.apibuilder.io/flow/catalog/0.3.56/play_2_x_standalone_json
 */
package io.flow.catalog.v0.models {

  /**
   * An item function can be represented with just its Id, or the entire model
   */
  sealed trait ExpandableItemFunction extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableItemFunction
   */
  sealed trait ExpandableItemFunctionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableItemFunctionDiscriminator {

    case object ItemFunction extends ExpandableItemFunctionDiscriminator { override def toString = "item_function" }
    case object ItemFunctionReference extends ExpandableItemFunctionDiscriminator { override def toString = "item_function_reference" }

    case class UNDEFINED(override val toString: String) extends ExpandableItemFunctionDiscriminator

    val all: scala.List[ExpandableItemFunctionDiscriminator] = scala.List(ItemFunction, ItemFunctionReference)

    private[this] val byName: Map[String, ExpandableItemFunctionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableItemFunctionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableItemFunctionDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * A subcatalog can be represented with just it's ID, or the entire model
   */
  sealed trait ExpandableSubcatalog extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableSubcatalog
   */
  sealed trait ExpandableSubcatalogDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableSubcatalogDiscriminator {

    case object Subcatalog extends ExpandableSubcatalogDiscriminator { override def toString = "subcatalog" }
    case object SubcatalogReference extends ExpandableSubcatalogDiscriminator { override def toString = "subcatalog_reference" }

    case class UNDEFINED(override val toString: String) extends ExpandableSubcatalogDiscriminator

    val all: scala.List[ExpandableSubcatalogDiscriminator] = scala.List(Subcatalog, SubcatalogReference)

    private[this] val byName: Map[String, ExpandableSubcatalogDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableSubcatalogDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableSubcatalogDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * The localized prices for an item are returned as a list - the key of each
   * element is defined here
   */
  sealed trait LocalizedPrice extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid key values for the type LocalizedPrice
   */
  sealed trait LocalizedPriceKey extends _root_.scala.Product with _root_.scala.Serializable

  object LocalizedPriceKey {

    case object LocalizedItemPrice extends LocalizedPriceKey { override def toString = "localized_item_price" }
    case object LocalizedItemVat extends LocalizedPriceKey { override def toString = "localized_item_vat" }
    case object LocalizedItemDuty extends LocalizedPriceKey { override def toString = "localized_item_duty" }
    case object LocalizedTotal extends LocalizedPriceKey { override def toString = "localized_total" }

    case class UNDEFINED(override val toString: String) extends LocalizedPriceKey

    val all: scala.List[LocalizedPriceKey] = scala.List(LocalizedItemPrice, LocalizedItemVat, LocalizedItemDuty, LocalizedTotal)

    private[this] val byName: Map[String, LocalizedPriceKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LocalizedPriceKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LocalizedPriceKey] = byName.get(value.toLowerCase)

  }

  /**
   * @param key
   * @param label The label for the adjustment reason that can be displayed as a
   * tooltip on the product detail page.
   */
  case class AdjustmentReason(
    key: io.flow.catalog.v0.models.AdjustmentReasonKey,
    label: String
  )

  /**
   * An attribute can be configured to be used in different ways throughout Flow. A
   * common example is to identify a meaningful attribute (e.g. brand) that can then
   * be displayed throughout the Flow console.
   * @param `type` Optionally tag attributes with their data type so they are
   * properly validated. If omitted, we will default to string
   * @param intent Optionally specify the meaning of this attribute to ensure
   * accurate processing, such as marking a price that should be localized. Note that
   * specifying an intent may restrict what data types are legal -- for example, a
   * price must also be of type decimal.
   * @param label A human-readable label used for display purposes.
   * @param key The key of the attribute that identifies it within a map of
   * attributes.
   * @param options Defines special rules for handling this attribute.
   * @param id The unique identifier for the attribute.
   */
  case class Attribute(
    id: String,
    key: String,
    options: io.flow.catalog.v0.models.Options,
    label: _root_.scala.Option[String] = None,
    intent: _root_.scala.Option[io.flow.catalog.v0.models.AttributeIntent] = None,
    `type`: _root_.scala.Option[io.flow.catalog.v0.models.AttributeDataType] = None
  )

  /**
   * @param `type` Optionally tag attributes with their data type so they are
   * properly validated. If omitted, we will default to string
   * @param intent Optionally specify the meaning of this attribute to ensure
   * accurate processing, such as marking a price that should be localized. Note that
   * specifying an intent may restrict what data types are legal -- for example, a
   * price must also be of type decimal.
   * @param label A human-readable label used for display purposes
   * @param key The actual attribute key. This key should match the keys used in the
   * item.attributes maps
   * @param options Defines the configuration for how the options are used through
   * flow
   */
  case class AttributeForm(
    key: String,
    options: io.flow.catalog.v0.models.Options,
    label: _root_.scala.Option[String] = None,
    intent: _root_.scala.Option[io.flow.catalog.v0.models.AttributeIntent] = None,
    `type`: _root_.scala.Option[io.flow.catalog.v0.models.AttributeDataType] = None
  )

  /**
   * Retrieve journaled history of an attribute
   */
  case class AttributeVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    attribute: io.flow.catalog.v0.models.Attribute
  )

  case class Catalog(
    id: String
  )

  case class CatalogReference(
    id: String
  )

  /**
   * Statistics covering product catalog item information, including total catalog
   * item count, number of distinct categories, etc.
   * @param items Total number of catalog items available from master catalog
   * @param categories Distinct number of catalog item categories
   */
  case class CatalogStatistics(
    items: Long,
    categories: Long
  )

  case class CatalogVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    catalog: io.flow.catalog.v0.models.Catalog
  )

  case class FlowItemIndexMetadata(
    status: io.flow.catalog.v0.models.SubcatalogItemStatus
  )

  /**
   * The URL to an image, with optional tags. Flow Commerce primarily uses images to
   * enhance the administrative tools (e.g. showing an item image in console)
   * @param url The full URL to the image
   * @param tags Tags can be used to identify the type of image being sent
   */
  case class Image(
    url: String,
    tags: Seq[String] = Nil
  )

  /**
   * Image form defines the data needed to create an image
   * @param url The full URL to the image
   * @param tags Optional tags that can keep track of which image this is
   */
  case class ImageForm(
    url: String,
    tags: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * @param key
   * @param label The label for the included levies that can be displayed as a
   * tooltip on the product detail page.
   */
  case class IncludedLevies(
    key: io.flow.catalog.v0.models.IncludedLevyKey,
    label: String
  )

  /**
   * The Flow item defines a specific item that can be purchased by a consumer. For
   * many clients, this will map to a Sku.
   * @param number
   * @param name
   * @param description
   * @param price
   * @param local
   * @param attributes Attributes of the items. An attribute of type intent must be
   * given as a string representation of a decimal to be correctly localized.
   * @param locale
   * @param id
   * @param categories
   * @param dimensions
   * @param images
   */
  case class Item(
    id: String,
    number: String,
    locale: String,
    name: String,
    price: io.flow.common.v0.models.Price,
    categories: Seq[String] = Nil,
    description: _root_.scala.Option[String] = None,
    attributes: Map[String, String] = Map.empty,
    dimensions: io.flow.common.v0.models.Dimensions,
    images: Seq[io.flow.catalog.v0.models.Image] = Nil,
    local: _root_.scala.Option[io.flow.catalog.v0.models.Local] = None
  )

  /**
   * The item form defines the data required to create an item.
   * @param number
   * @param name The customer friendly name of the actual item in the catalog.
   * @param description If provided, the item description is used to improve
   * classification.
   * @param price The actual price of the item as offered to a customer. This price
   * must be in the currency specified for this item.
   * @param attributes Attributes represent all other product data that you have
   * regarding this item. Common attributes include 'country_of_origin', 'color',
   * 'size', 'material', etc. We recommend including as many attributes as possible,
   * even if you are not currently planning to use them.
   * @param locale The locale in which the content of this item is written.
   * @param categories A list of categories associated with this item.
   * @param dimensions If provided, dimensions are used to drive more accurate
   * shipping estimates.
   * @param currency ISO 4217 3 currency code as defined in
   * https://api.flow.io/reference/currencies
   * @param images If provided, the item images will be used to enhance the user
   * experience in Flow's online tools.
   */
  case class ItemForm(
    number: String,
    locale: String,
    name: String,
    currency: String,
    price: Double,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    dimensions: _root_.scala.Option[io.flow.common.v0.models.Dimensions] = None,
    images: _root_.scala.Option[Seq[io.flow.catalog.v0.models.ImageForm]] = None
  )

  /**
   * Item Functions are javascript code used to calculate the localized price of an
   * additional item. Each function can be associated with an optional query
   * identifying the products to which the function applies. Flow selects the first
   * function matching an item, then uses that function to calculate local prices
   * whenever any data relevant to the item changes (e.g. on update in master
   * catalog, on change in relevant exchange rate, etc.). Item functions are
   * immutable once created.
   * @param id
   * @param key Unique, url friendly key identifying this function
   * @param description Details of what the item function actually does
   * @param code
   */
  case class ItemFunction(
    id: String,
    key: String,
    description: String,
    code: String
  ) extends ExpandableItemFunction

  /**
   * Item Functions are javascript code used to calculate the localized price of an
   * additional item. Each function can be associated with an optional query
   * identifying the products to which the function applies. Flow selects the first
   * function matching an item, then uses that function to calculate local prices
   * whenever any data relevant to the item changes (e.g. on update in master
   * catalog, on change in relevant exchange rate, etc.). Item functions are
   * immutable once created.
   * @param description Details of what the item function actually does
   * @param code
   * @param key Unique key to identify this function. If not specified, generated
   * server side as the lowercase, hex encoded, Sha-256 of the source code itself
   */
  case class ItemFunctionPostForm(
    description: String,
    code: String,
    key: _root_.scala.Option[String] = None
  )

  /**
   * Item Functions are javascript code used to calculate the localized price of an
   * additional item. Each function can be associated with an optional query
   * identifying the products to which the function applies. Flow selects the first
   * function matching an item, then uses that function to calculate local prices
   * whenever any data relevant to the item changes (e.g. on update in master
   * catalog, on change in relevant exchange rate, etc.). Item functions are
   * immutable once created.
   * @param description Details of what the item function actually does
   * @param code
   */
  case class ItemFunctionPutForm(
    description: String,
    code: String
  )

  case class ItemFunctionReference(
    id: String
  ) extends ExpandableItemFunction

  case class ItemFunctionVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    itemFunction: io.flow.catalog.v0.models.ItemFunction
  )

  /**
   * Statistics covering product catalog item information, including total catalog
   * item count, number of distinct categories, etc.
   * @param items Total number of catalog items available from master catalog
   * @param categories Distinct number of catalog item categories
   */
  case class ItemStatistics(
    items: Long,
    categories: Long
  )

  case class ItemVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    item: io.flow.catalog.v0.models.Item
  )

  /**
   * @param prices
   * @param priceAttributes This field contains the localized prices attributes.
   * @param attributes This field contains the localized attributes. For instance a
   * base attribute of intent price will be converted in the target currency.
   * @param spotRates
   * @param experience
   * @param rates
   * @param status
   */
  case class Local(
    experience: io.flow.common.v0.models.ExperienceSummary,
    prices: Seq[io.flow.catalog.v0.models.LocalizedPrice],
    rates: Seq[io.flow.currency.v0.models.Rate],
    @deprecated("This field is deprecated - you will see an empty array in the response") spotRates: Seq[_root_.play.api.libs.json.JsObject],
    status: io.flow.catalog.v0.models.SubcatalogItemStatus = io.flow.catalog.v0.models.SubcatalogItemStatus.Included,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    priceAttributes: _root_.scala.Option[Map[String, io.flow.common.v0.models.PriceWithBase]] = None
  )

  case class LocalizedAdjustment(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    reason: io.flow.catalog.v0.models.AdjustmentReason
  )

  /**
   * @param label
   * @param adjustment An adjustment may need to be applied to VAT at the order level
   * if the de minimis value is met; if so, its value is stored here.
   * @param amount
   * @param base
   * @param currency
   */
  case class LocalizedItemDuty(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    adjustment: _root_.scala.Option[io.flow.catalog.v0.models.LocalizedAdjustment] = None
  ) extends LocalizedPrice

  /**
   * @param label
   * @param amount
   * @param base
   * @param currency
   * @param includes Describes which levies are included in the price, if any.
   */
  case class LocalizedItemPrice(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    includes: _root_.scala.Option[io.flow.catalog.v0.models.IncludedLevies] = None
  ) extends LocalizedPrice

  /**
   * @param name The specific name of the tax in the local region.
   * @param label
   * @param adjustment An adjustment may need to be applied to VAT at the order level
   * if the de minimis value is met; if so, its value is stored here.
   * @param amount
   * @param base
   * @param currency
   */
  case class LocalizedItemVat(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    name: String,
    adjustment: _root_.scala.Option[io.flow.catalog.v0.models.LocalizedAdjustment] = None
  ) extends LocalizedPrice

  case class LocalizedTotal(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price
  ) extends LocalizedPrice

  /**
   * Flags to indicate whether a feature is enabled/disabled on a particular model
   * (e.g. show/do not show attribute as a column in harmonization table view of
   * items)
   * @param required If true, when you create or update items in Flow, we will
   * validate that data presented contains an attribute with this key.
   * @param showInCatalog Flag indicating that a feature is applicable to catalog and
   * can be used in Console
   * @param showInHarmonization Flag indicating that a feature is applicable to
   * harmoniztion and can be used in Console
   */
  case class Options(
    required: Boolean = false,
    showInCatalog: Boolean = false,
    showInHarmonization: Boolean = false
  )

  /**
   * Represents a typed query to indicate which items to include or exclude in a
   * subcatalog
   */
  case class Query(
    id: String,
    q: String,
    `type`: io.flow.catalog.v0.models.QueryType
  )

  /**
   * Defines a query specifying items to be included or excluded in a subcatalog
   * @param q Query string used to search for items
   * @param `type`
   */
  case class QueryForm(
    q: String,
    `type`: io.flow.catalog.v0.models.QueryType
  )

  /**
   * Indicates valid and invalid queries
   */
  case class QueryValidation(
    valid: Seq[String],
    invalid: Seq[String]
  )

  /**
   * A configuration with custom query to select a subset of master catalog items for
   * a localized experience
   */
  case class Subcatalog(
    id: String,
    catalog: io.flow.catalog.v0.models.Catalog,
    settings: io.flow.catalog.v0.models.SubcatalogSettings
  ) extends ExpandableSubcatalog

  case class SubcatalogForm(
    settings: _root_.scala.Option[io.flow.catalog.v0.models.SubcatalogSettingsForm] = None
  )

  /**
   * @param id
   * @param itemFunction
   * @param q Apply this pricing function to the items that match this query
   * @param position Functions are ordered. Lower position numbers indicate function
   * that should be applied earlier.
   */
  case class SubcatalogFunction(
    id: String,
    itemFunction: io.flow.catalog.v0.models.ItemFunction,
    q: String,
    position: Long
  )

  /**
   * @param itemFunctionId The Id of the item function to associate with this
   * subcatalog
   * @param q Optionally apply this pricing function only to the items that match
   * this query. If not specified, the pricing function will apply to all items.
   * @param position Functions are ordered. Lower position numbers indicate function
   * that should be applied earlier. Defaults to last in list.
   */
  case class SubcatalogFunctionForm(
    itemFunctionId: String,
    q: _root_.scala.Option[String] = None,
    position: _root_.scala.Option[Long] = None
  )

  case class SubcatalogFunctionVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    subcatalogFunction: io.flow.catalog.v0.models.SubcatalogFunction
  )

  /**
   * Represents information specific to an item in a given subcatalog
   */
  case class SubcatalogItem(
    id: String,
    item: io.flow.catalog.v0.models.Item,
    status: io.flow.catalog.v0.models.SubcatalogItemStatus,
    itemFunction: _root_.scala.Option[io.flow.catalog.v0.models.ExpandableItemFunction] = None
  )

  case class SubcatalogItemVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    subcatalogItem: io.flow.catalog.v0.models.SubcatalogItem
  )

  case class SubcatalogReference(
    id: String
  ) extends ExpandableSubcatalog

  case class SubcatalogSettings(
    updatePolicy: io.flow.catalog.v0.models.UpdatePolicy = io.flow.catalog.v0.models.UpdatePolicy.Auto
  )

  case class SubcatalogSettingsForm(
    updatePolicy: _root_.scala.Option[io.flow.catalog.v0.models.UpdatePolicy] = None
  )

  /**
   * Statistics related to the items in this subcatalog, including item count, number
   * of distinct categories, etc.
   * @param catalog The parent catalog's statistics. Provided here to make summary
   * data easy to compute (e.g. what % of items are in this subcatalog)
   * @param included Total number of catalog items available from master catalog
   * @param queue Number of items that are currently queued to be added or updated to
   * this subcatalog
   * @param restricted Number of items that are currently restricted in this
   * subcatalog
   * @param excluded Number of items that are currently excluded in this subcatalog
   */
  case class SubcatalogStatistics(
    excluded: io.flow.catalog.v0.models.ItemStatistics,
    included: io.flow.catalog.v0.models.ItemStatistics,
    restricted: io.flow.catalog.v0.models.ItemStatistics,
    queue: io.flow.catalog.v0.models.ItemStatistics,
    catalog: io.flow.catalog.v0.models.CatalogStatistics
  )

  case class SubcatalogVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    subcatalog: io.flow.catalog.v0.models.Subcatalog
  )

  /**
   * @param catalog
   * @param queries Tuples of valid queries on a catalog and their corresponding
   * output object in the client service
   * @param key Unique client-provided identifier indicating uniqueness of the
   * targeting request. Follows the convention: [service]-[model]-[id]. For example:
   * ratecard-dimension-estimate-dst-8eec70ab1f2740e0b46c7c8867cd8e07
   * @param id
   * @param subcatalog
   */
  case class Targeting(
    id: String,
    key: String,
    queries: Seq[io.flow.catalog.v0.models.TargetingQuery],
    catalog: io.flow.catalog.v0.models.CatalogReference,
    subcatalog: _root_.scala.Option[io.flow.catalog.v0.models.SubcatalogReference] = None
  )

  /**
   * @param key Unique client-provided identifier indicating uniqueness of the
   * targeting request. Follows the convention: [service]-[model]-[id]. For example:
   * ratecard-dimension-estimate-dst-8eec70ab1f2740e0b46c7c8867cd8e07
   * @param queries Tuples of valid queries on a catalog and their corresponding
   * output object in the client service
   * @param subcatalogId If a targeting is only for a specific subcatalog, then this
   * needs to be provided
   */
  case class TargetingForm(
    key: String,
    queries: Seq[io.flow.catalog.v0.models.TargetingQueryForm],
    subcatalogId: _root_.scala.Option[String] = None
  )

  /**
   * Represents catalog items where a targeteing query is applicable
   */
  case class TargetingItem(
    id: String,
    targeting: io.flow.catalog.v0.models.TargetingSummary,
    itemNumber: String,
    query: io.flow.catalog.v0.models.TargetingQuery
  )

  /**
   * @param id
   * @param q Valid query on the organization's catalog items
   * @param outcomeId ID of corresponding outcome object in client service (e.g. item
   * margin, dimension estimate, etc)
   * @param position
   */
  case class TargetingQuery(
    id: String,
    q: String,
    outcomeId: String,
    position: Long
  )

  /**
   * @param q Valid query on the organization's catalog items
   * @param outcomeId ID of corresponding outcome object in client service (e.g. item
   * margin, dimension estimate, etc)
   */
  case class TargetingQueryForm(
    q: String,
    outcomeId: String
  )

  case class TargetingSummary(
    id: String,
    key: String,
    catalog: io.flow.catalog.v0.models.CatalogReference,
    subcatalog: _root_.scala.Option[io.flow.catalog.v0.models.SubcatalogReference] = None
  )

  case class TargetingVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    targeting: io.flow.catalog.v0.models.Targeting
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableItemFunction, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * @param description Information about the type that we received that is undefined
   * in this version of the client.
   */
  case class ExpandableItemFunctionUndefinedType(
    description: String
  ) extends ExpandableItemFunction

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableSubcatalog, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * @param description Information about the type that we received that is undefined
   * in this version of the client.
   */
  case class ExpandableSubcatalogUndefinedType(
    description: String
  ) extends ExpandableSubcatalog

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union LocalizedPrice, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * @param description Information about the type that we received that is undefined
   * in this version of the client.
   */
  case class LocalizedPriceUndefinedType(
    description: String
  ) extends LocalizedPrice

  /**
   * The key of each possible adjustment is defined here.
   */
  sealed trait AdjustmentReasonKey extends _root_.scala.Product with _root_.scala.Serializable

  object AdjustmentReasonKey {

    /**
     * If the duty de minimis value has not been met, an adjustment may be made to
     * offset any previously calculated duty.
     */
    case object DutyDeminimis extends AdjustmentReasonKey { override def toString = "duty_deminimis" }
    /**
     * If the VAT de minimis value has not been met, an adjustment may be made to
     * offset any previously calculated VAT.
     */
    case object VatDeminimis extends AdjustmentReasonKey { override def toString = "vat_deminimis" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends AdjustmentReasonKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AdjustmentReasonKey] = scala.List(DutyDeminimis, VatDeminimis)

    private[this]
    val byName: Map[String, AdjustmentReasonKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AdjustmentReasonKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AdjustmentReasonKey] = byName.get(value.toLowerCase)

  }

  /**
   * Used to tag attributes with a data type so they are properly validated.
   */
  sealed trait AttributeDataType extends _root_.scala.Product with _root_.scala.Serializable

  object AttributeDataType {

    /**
     * Decimal datatype without size or precision restrictions. Commonly used for
     * currency values.
     */
    case object Decimal extends AttributeDataType { override def toString = "decimal" }
    /**
     * Unvalidated string of characters.
     */
    case object String extends AttributeDataType { override def toString = "string" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends AttributeDataType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AttributeDataType] = scala.List(Decimal, String)

    private[this]
    val byName: Map[String, AttributeDataType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AttributeDataType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AttributeDataType] = byName.get(value.toLowerCase)

  }

  /**
   * Used to tag attributes as having a specific meaning that can affect processing.
   */
  sealed trait AttributeIntent extends _root_.scala.Product with _root_.scala.Serializable

  object AttributeIntent {

    /**
     * Attributes with this data type imply that this is the brand name of the item for
     * retailers that sell multiple brands
     */
    case object Brand extends AttributeIntent { override def toString = "brand" }
    /**
     * Attributes with this data type imply whether delivery is a package or digital
     * good.
     */
    case object FulfillmentMethod extends AttributeIntent { override def toString = "fulfillment_method" }
    /**
     * Attributes with this data type are inferred to be prices in the organization's
     * base currency and will be localized based on each Experience's pricing policy.
     */
    case object Price extends AttributeIntent { override def toString = "price" }
    /**
     * Attributes with this data type imply whether taxes are applicable to an item.
     */
    case object Taxability extends AttributeIntent { override def toString = "taxability" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends AttributeIntent

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AttributeIntent] = scala.List(Brand, FulfillmentMethod, Price, Taxability)

    private[this]
    val byName: Map[String, AttributeIntent] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AttributeIntent = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AttributeIntent] = byName.get(value.toLowerCase)

  }

  /**
   * Used to indicate an item's fulfillment method type.
   */
  sealed trait FulfillmentMethodType extends _root_.scala.Product with _root_.scala.Serializable

  object FulfillmentMethodType {

    /**
     * Indicates how an item will be shipped or fulfilled.  Acceptable values are
     * defined by the 'fulfillment_method_value' enum.
     */
    case object FulfillmentMethod extends FulfillmentMethodType { override def toString = "fulfillment_method" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends FulfillmentMethodType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[FulfillmentMethodType] = scala.List(FulfillmentMethod)

    private[this]
    val byName: Map[String, FulfillmentMethodType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): FulfillmentMethodType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[FulfillmentMethodType] = byName.get(value.toLowerCase)

  }

  /**
   * Used to indicate an item's fulfillment method values.
   */
  sealed trait FulfillmentMethodValue extends _root_.scala.Product with _root_.scala.Serializable

  object FulfillmentMethodValue {

    /**
     * Indicates item will be fulfilled digitally and no shipment is required (e.g.
     * Gift Card).
     */
    case object Digital extends FulfillmentMethodValue { override def toString = "digital" }
    /**
     * Indicates item will be shipped in a phystical package.
     */
    case object Physical extends FulfillmentMethodValue { override def toString = "physical" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends FulfillmentMethodValue

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[FulfillmentMethodValue] = scala.List(Digital, Physical)

    private[this]
    val byName: Map[String, FulfillmentMethodValue] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): FulfillmentMethodValue = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[FulfillmentMethodValue] = byName.get(value.toLowerCase)

  }

  /**
   * The key of each possible localized price note is defined here.
   */
  sealed trait IncludedLevyKey extends _root_.scala.Product with _root_.scala.Serializable

  object IncludedLevyKey {

    case object Duty extends IncludedLevyKey { override def toString = "duty" }
    case object Vat extends IncludedLevyKey { override def toString = "vat" }
    case object VatAndDuty extends IncludedLevyKey { override def toString = "vat_and_duty" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends IncludedLevyKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[IncludedLevyKey] = scala.List(Duty, Vat, VatAndDuty)

    private[this]
    val byName: Map[String, IncludedLevyKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): IncludedLevyKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[IncludedLevyKey] = byName.get(value.toLowerCase)

  }

  /**
   * Type to indicate whether query is an inclusion or exclusion
   */
  sealed trait QueryType extends _root_.scala.Product with _root_.scala.Serializable

  object QueryType {

    /**
     * Exclude items satisfied by the associated query
     */
    case object Exclusion extends QueryType { override def toString = "exclusion" }
    /**
     * Include items satisfied by the associated query
     */
    case object Inclusion extends QueryType { override def toString = "inclusion" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends QueryType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[QueryType] = scala.List(Exclusion, Inclusion)

    private[this]
    val byName: Map[String, QueryType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): QueryType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[QueryType] = byName.get(value.toLowerCase)

  }

  /**
   * Status indicating availability of a subcatalog item in an experience.
   */
  sealed trait SubcatalogItemStatus extends _root_.scala.Product with _root_.scala.Serializable

  object SubcatalogItemStatus {

    /**
     * The user has chosen to exclude the item from the associated subcatalog.
     */
    case object Excluded extends SubcatalogItemStatus { override def toString = "excluded" }
    /**
     * The item is included in the associated subcatalog.
     */
    case object Included extends SubcatalogItemStatus { override def toString = "included" }
    /**
     * Item is not allowed to be sold in the market associated with the given
     * subcatalog.
     */
    case object Restricted extends SubcatalogItemStatus { override def toString = "restricted" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends SubcatalogItemStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[SubcatalogItemStatus] = scala.List(Excluded, Included, Restricted)

    private[this]
    val byName: Map[String, SubcatalogItemStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): SubcatalogItemStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[SubcatalogItemStatus] = byName.get(value.toLowerCase)

  }

  sealed trait TaxabilityType extends _root_.scala.Product with _root_.scala.Serializable

  object TaxabilityType {

    /**
     * Rule indicating how taxes should be applied.  Acceptable values are defined by
     * the 'taxability_value' enum.
     */
    case object TaxRule extends TaxabilityType { override def toString = "tax_rule" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends TaxabilityType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxabilityType] = scala.List(TaxRule)

    private[this]
    val byName: Map[String, TaxabilityType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxabilityType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxabilityType] = byName.get(value.toLowerCase)

  }

  /**
   * Used to indicate an item's taxability.
   */
  sealed trait TaxabilityValue extends _root_.scala.Product with _root_.scala.Serializable

  object TaxabilityValue {

    /**
     * An item with this value is exempt from being taxed.
     */
    case object Exempt extends TaxabilityValue { override def toString = "exempt" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends TaxabilityValue

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxabilityValue] = scala.List(Exempt)

    private[this]
    val byName: Map[String, TaxabilityValue] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxabilityValue = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxabilityValue] = byName.get(value.toLowerCase)

  }

  sealed trait UpdatePolicy extends _root_.scala.Product with _root_.scala.Serializable

  object UpdatePolicy {

    case object Auto extends UpdatePolicy { override def toString = "auto" }
    /**
     * Queue item update for approval.
     */
    case object Queue extends UpdatePolicy { override def toString = "queue" }
    case object Discard extends UpdatePolicy { override def toString = "discard" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends UpdatePolicy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[UpdatePolicy] = scala.List(Auto, Queue, Discard)

    private[this]
    val byName: Map[String, UpdatePolicy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UpdatePolicy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UpdatePolicy] = byName.get(value.toLowerCase)

  }

}

package io.flow.catalog.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.catalog.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.currency.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.price.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsCatalogAdjustmentReasonKey = new play.api.libs.json.Reads[io.flow.catalog.v0.models.AdjustmentReasonKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.AdjustmentReasonKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AdjustmentReasonKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AdjustmentReasonKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogAdjustmentReasonKey(obj: io.flow.catalog.v0.models.AdjustmentReasonKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAdjustmentReasonKey(obj: io.flow.catalog.v0.models.AdjustmentReasonKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogAdjustmentReasonKey: play.api.libs.json.Writes[AdjustmentReasonKey] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AdjustmentReasonKey] {
        def writes(obj: io.flow.catalog.v0.models.AdjustmentReasonKey) = {
          jsonWritesCatalogAdjustmentReasonKey(obj)
        }
      }
    }

    implicit val jsonReadsCatalogAttributeDataType = new play.api.libs.json.Reads[io.flow.catalog.v0.models.AttributeDataType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.AttributeDataType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AttributeDataType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AttributeDataType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogAttributeDataType(obj: io.flow.catalog.v0.models.AttributeDataType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAttributeDataType(obj: io.flow.catalog.v0.models.AttributeDataType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogAttributeDataType: play.api.libs.json.Writes[AttributeDataType] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AttributeDataType] {
        def writes(obj: io.flow.catalog.v0.models.AttributeDataType) = {
          jsonWritesCatalogAttributeDataType(obj)
        }
      }
    }

    implicit val jsonReadsCatalogAttributeIntent = new play.api.libs.json.Reads[io.flow.catalog.v0.models.AttributeIntent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.AttributeIntent] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AttributeIntent(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AttributeIntent(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogAttributeIntent(obj: io.flow.catalog.v0.models.AttributeIntent) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAttributeIntent(obj: io.flow.catalog.v0.models.AttributeIntent) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogAttributeIntent: play.api.libs.json.Writes[AttributeIntent] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AttributeIntent] {
        def writes(obj: io.flow.catalog.v0.models.AttributeIntent) = {
          jsonWritesCatalogAttributeIntent(obj)
        }
      }
    }

    implicit val jsonReadsCatalogFulfillmentMethodType = new play.api.libs.json.Reads[io.flow.catalog.v0.models.FulfillmentMethodType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.FulfillmentMethodType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogFulfillmentMethodType(obj: io.flow.catalog.v0.models.FulfillmentMethodType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectFulfillmentMethodType(obj: io.flow.catalog.v0.models.FulfillmentMethodType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogFulfillmentMethodType: play.api.libs.json.Writes[FulfillmentMethodType] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.FulfillmentMethodType] {
        def writes(obj: io.flow.catalog.v0.models.FulfillmentMethodType) = {
          jsonWritesCatalogFulfillmentMethodType(obj)
        }
      }
    }

    implicit val jsonReadsCatalogFulfillmentMethodValue = new play.api.libs.json.Reads[io.flow.catalog.v0.models.FulfillmentMethodValue] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.FulfillmentMethodValue] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodValue(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodValue(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogFulfillmentMethodValue(obj: io.flow.catalog.v0.models.FulfillmentMethodValue) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectFulfillmentMethodValue(obj: io.flow.catalog.v0.models.FulfillmentMethodValue) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogFulfillmentMethodValue: play.api.libs.json.Writes[FulfillmentMethodValue] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.FulfillmentMethodValue] {
        def writes(obj: io.flow.catalog.v0.models.FulfillmentMethodValue) = {
          jsonWritesCatalogFulfillmentMethodValue(obj)
        }
      }
    }

    implicit val jsonReadsCatalogIncludedLevyKey = new play.api.libs.json.Reads[io.flow.catalog.v0.models.IncludedLevyKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.IncludedLevyKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.IncludedLevyKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.IncludedLevyKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogIncludedLevyKey(obj: io.flow.catalog.v0.models.IncludedLevyKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectIncludedLevyKey(obj: io.flow.catalog.v0.models.IncludedLevyKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogIncludedLevyKey: play.api.libs.json.Writes[IncludedLevyKey] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.IncludedLevyKey] {
        def writes(obj: io.flow.catalog.v0.models.IncludedLevyKey) = {
          jsonWritesCatalogIncludedLevyKey(obj)
        }
      }
    }

    implicit val jsonReadsCatalogQueryType = new play.api.libs.json.Reads[io.flow.catalog.v0.models.QueryType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.QueryType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.QueryType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.QueryType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogQueryType(obj: io.flow.catalog.v0.models.QueryType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectQueryType(obj: io.flow.catalog.v0.models.QueryType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogQueryType: play.api.libs.json.Writes[QueryType] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.QueryType] {
        def writes(obj: io.flow.catalog.v0.models.QueryType) = {
          jsonWritesCatalogQueryType(obj)
        }
      }
    }

    implicit val jsonReadsCatalogSubcatalogItemStatus = new play.api.libs.json.Reads[io.flow.catalog.v0.models.SubcatalogItemStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.SubcatalogItemStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.SubcatalogItemStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.SubcatalogItemStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogSubcatalogItemStatus(obj: io.flow.catalog.v0.models.SubcatalogItemStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectSubcatalogItemStatus(obj: io.flow.catalog.v0.models.SubcatalogItemStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogSubcatalogItemStatus: play.api.libs.json.Writes[SubcatalogItemStatus] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogItemStatus] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogItemStatus) = {
          jsonWritesCatalogSubcatalogItemStatus(obj)
        }
      }
    }

    implicit val jsonReadsCatalogTaxabilityType = new play.api.libs.json.Reads[io.flow.catalog.v0.models.TaxabilityType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.TaxabilityType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogTaxabilityType(obj: io.flow.catalog.v0.models.TaxabilityType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxabilityType(obj: io.flow.catalog.v0.models.TaxabilityType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogTaxabilityType: play.api.libs.json.Writes[TaxabilityType] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TaxabilityType] {
        def writes(obj: io.flow.catalog.v0.models.TaxabilityType) = {
          jsonWritesCatalogTaxabilityType(obj)
        }
      }
    }

    implicit val jsonReadsCatalogTaxabilityValue = new play.api.libs.json.Reads[io.flow.catalog.v0.models.TaxabilityValue] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.TaxabilityValue] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityValue(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityValue(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogTaxabilityValue(obj: io.flow.catalog.v0.models.TaxabilityValue) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxabilityValue(obj: io.flow.catalog.v0.models.TaxabilityValue) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogTaxabilityValue: play.api.libs.json.Writes[TaxabilityValue] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TaxabilityValue] {
        def writes(obj: io.flow.catalog.v0.models.TaxabilityValue) = {
          jsonWritesCatalogTaxabilityValue(obj)
        }
      }
    }

    implicit val jsonReadsCatalogUpdatePolicy = new play.api.libs.json.Reads[io.flow.catalog.v0.models.UpdatePolicy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.UpdatePolicy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.UpdatePolicy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.UpdatePolicy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogUpdatePolicy(obj: io.flow.catalog.v0.models.UpdatePolicy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUpdatePolicy(obj: io.flow.catalog.v0.models.UpdatePolicy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogUpdatePolicy: play.api.libs.json.Writes[UpdatePolicy] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.UpdatePolicy] {
        def writes(obj: io.flow.catalog.v0.models.UpdatePolicy) = {
          jsonWritesCatalogUpdatePolicy(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAdjustmentReason: play.api.libs.json.Reads[AdjustmentReason] = {
      (
        (__ \ "key").read[io.flow.catalog.v0.models.AdjustmentReasonKey] and
        (__ \ "label").read[String]
      )(AdjustmentReason.apply _)
    }

    def jsObjectAdjustmentReason(obj: io.flow.catalog.v0.models.AdjustmentReason): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesCatalogAdjustmentReason: play.api.libs.json.Writes[AdjustmentReason] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AdjustmentReason] {
        def writes(obj: io.flow.catalog.v0.models.AdjustmentReason) = {
          jsObjectAdjustmentReason(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAttribute: play.api.libs.json.Reads[Attribute] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "options").read[io.flow.catalog.v0.models.Options] and
        (__ \ "label").readNullable[String] and
        (__ \ "intent").readNullable[io.flow.catalog.v0.models.AttributeIntent] and
        (__ \ "type").readNullable[io.flow.catalog.v0.models.AttributeDataType]
      )(Attribute.apply _)
    }

    def jsObjectAttribute(obj: io.flow.catalog.v0.models.Attribute): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "options" -> jsObjectOptions(obj.options)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.intent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("intent" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.`type` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("type" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesCatalogAttribute: play.api.libs.json.Writes[Attribute] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Attribute] {
        def writes(obj: io.flow.catalog.v0.models.Attribute) = {
          jsObjectAttribute(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAttributeForm: play.api.libs.json.Reads[AttributeForm] = {
      (
        (__ \ "key").read[String] and
        (__ \ "options").read[io.flow.catalog.v0.models.Options] and
        (__ \ "label").readNullable[String] and
        (__ \ "intent").readNullable[io.flow.catalog.v0.models.AttributeIntent] and
        (__ \ "type").readNullable[io.flow.catalog.v0.models.AttributeDataType]
      )(AttributeForm.apply _)
    }

    def jsObjectAttributeForm(obj: io.flow.catalog.v0.models.AttributeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "options" -> jsObjectOptions(obj.options)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.intent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("intent" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.`type` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("type" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesCatalogAttributeForm: play.api.libs.json.Writes[AttributeForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AttributeForm] {
        def writes(obj: io.flow.catalog.v0.models.AttributeForm) = {
          jsObjectAttributeForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAttributeVersion: play.api.libs.json.Reads[AttributeVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "attribute").read[io.flow.catalog.v0.models.Attribute]
      )(AttributeVersion.apply _)
    }

    def jsObjectAttributeVersion(obj: io.flow.catalog.v0.models.AttributeVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "attribute" -> jsObjectAttribute(obj.attribute)
      )
    }

    implicit def jsonWritesCatalogAttributeVersion: play.api.libs.json.Writes[AttributeVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AttributeVersion] {
        def writes(obj: io.flow.catalog.v0.models.AttributeVersion) = {
          jsObjectAttributeVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalog: play.api.libs.json.Reads[Catalog] = {
      (__ \ "id").read[String].map { x => new Catalog(id = x) }
    }

    def jsObjectCatalog(obj: io.flow.catalog.v0.models.Catalog): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesCatalogCatalog: play.api.libs.json.Writes[Catalog] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Catalog] {
        def writes(obj: io.flow.catalog.v0.models.Catalog) = {
          jsObjectCatalog(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalogReference: play.api.libs.json.Reads[CatalogReference] = {
      (__ \ "id").read[String].map { x => new CatalogReference(id = x) }
    }

    def jsObjectCatalogReference(obj: io.flow.catalog.v0.models.CatalogReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesCatalogCatalogReference: play.api.libs.json.Writes[CatalogReference] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.CatalogReference] {
        def writes(obj: io.flow.catalog.v0.models.CatalogReference) = {
          jsObjectCatalogReference(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalogStatistics: play.api.libs.json.Reads[CatalogStatistics] = {
      (
        (__ \ "items").read[Long] and
        (__ \ "categories").read[Long]
      )(CatalogStatistics.apply _)
    }

    def jsObjectCatalogStatistics(obj: io.flow.catalog.v0.models.CatalogStatistics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.JsNumber(obj.items),
        "categories" -> play.api.libs.json.JsNumber(obj.categories)
      )
    }

    implicit def jsonWritesCatalogCatalogStatistics: play.api.libs.json.Writes[CatalogStatistics] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.CatalogStatistics] {
        def writes(obj: io.flow.catalog.v0.models.CatalogStatistics) = {
          jsObjectCatalogStatistics(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalogVersion: play.api.libs.json.Reads[CatalogVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "catalog").read[io.flow.catalog.v0.models.Catalog]
      )(CatalogVersion.apply _)
    }

    def jsObjectCatalogVersion(obj: io.flow.catalog.v0.models.CatalogVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "catalog" -> jsObjectCatalog(obj.catalog)
      )
    }

    implicit def jsonWritesCatalogCatalogVersion: play.api.libs.json.Writes[CatalogVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.CatalogVersion] {
        def writes(obj: io.flow.catalog.v0.models.CatalogVersion) = {
          jsObjectCatalogVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogFlowItemIndexMetadata: play.api.libs.json.Reads[FlowItemIndexMetadata] = {
      (__ \ "status").read[io.flow.catalog.v0.models.SubcatalogItemStatus].map { x => new FlowItemIndexMetadata(status = x) }
    }

    def jsObjectFlowItemIndexMetadata(obj: io.flow.catalog.v0.models.FlowItemIndexMetadata): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesCatalogFlowItemIndexMetadata: play.api.libs.json.Writes[FlowItemIndexMetadata] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.FlowItemIndexMetadata] {
        def writes(obj: io.flow.catalog.v0.models.FlowItemIndexMetadata) = {
          jsObjectFlowItemIndexMetadata(obj)
        }
      }
    }

    implicit def jsonReadsCatalogImage: play.api.libs.json.Reads[Image] = {
      (
        (__ \ "url").read[String] and
        (__ \ "tags").read[Seq[String]]
      )(Image.apply _)
    }

    def jsObjectImage(obj: io.flow.catalog.v0.models.Image): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "tags" -> play.api.libs.json.Json.toJson(obj.tags)
      )
    }

    implicit def jsonWritesCatalogImage: play.api.libs.json.Writes[Image] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Image] {
        def writes(obj: io.flow.catalog.v0.models.Image) = {
          jsObjectImage(obj)
        }
      }
    }

    implicit def jsonReadsCatalogImageForm: play.api.libs.json.Reads[ImageForm] = {
      (
        (__ \ "url").read[String] and
        (__ \ "tags").readNullable[Seq[String]]
      )(ImageForm.apply _)
    }

    def jsObjectImageForm(obj: io.flow.catalog.v0.models.ImageForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url)
      ) ++ (obj.tags match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tags" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogImageForm: play.api.libs.json.Writes[ImageForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ImageForm] {
        def writes(obj: io.flow.catalog.v0.models.ImageForm) = {
          jsObjectImageForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogIncludedLevies: play.api.libs.json.Reads[IncludedLevies] = {
      (
        (__ \ "key").read[io.flow.catalog.v0.models.IncludedLevyKey] and
        (__ \ "label").read[String]
      )(IncludedLevies.apply _)
    }

    def jsObjectIncludedLevies(obj: io.flow.catalog.v0.models.IncludedLevies): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesCatalogIncludedLevies: play.api.libs.json.Writes[IncludedLevies] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.IncludedLevies] {
        def writes(obj: io.flow.catalog.v0.models.IncludedLevies) = {
          jsObjectIncludedLevies(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItem: play.api.libs.json.Reads[Item] = {
      (
        (__ \ "id").read[String] and
        (__ \ "number").read[String] and
        (__ \ "locale").read[String] and
        (__ \ "name").read[String] and
        (__ \ "price").read[io.flow.common.v0.models.Price] and
        (__ \ "categories").read[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").read[Map[String, String]] and
        (__ \ "dimensions").read[io.flow.common.v0.models.Dimensions] and
        (__ \ "images").read[Seq[io.flow.catalog.v0.models.Image]] and
        (__ \ "local").readNullable[io.flow.catalog.v0.models.Local]
      )(Item.apply _)
    }

    def jsObjectItem(obj: io.flow.catalog.v0.models.Item): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "dimensions" -> io.flow.common.v0.models.json.jsObjectDimensions(obj.dimensions),
        "images" -> play.api.libs.json.Json.toJson(obj.images)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.local match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("local" -> jsObjectLocal(x))
      })
    }

    implicit def jsonWritesCatalogItem: play.api.libs.json.Writes[Item] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Item] {
        def writes(obj: io.flow.catalog.v0.models.Item) = {
          jsObjectItem(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemForm: play.api.libs.json.Reads[ItemForm] = {
      (
        (__ \ "number").read[String] and
        (__ \ "locale").read[String] and
        (__ \ "name").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "price").read[Double] and
        (__ \ "categories").readNullable[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").readNullable[Map[String, String]] and
        (__ \ "dimensions").readNullable[io.flow.common.v0.models.Dimensions] and
        (__ \ "images").readNullable[Seq[io.flow.catalog.v0.models.ImageForm]]
      )(ItemForm.apply _)
    }

    def jsObjectItemForm(obj: io.flow.catalog.v0.models.ItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.dimensions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("dimensions" -> io.flow.common.v0.models.json.jsObjectDimensions(x))
      }) ++
      (obj.images match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("images" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogItemForm: play.api.libs.json.Writes[ItemForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemForm] {
        def writes(obj: io.flow.catalog.v0.models.ItemForm) = {
          jsObjectItemForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemFunction: play.api.libs.json.Reads[ItemFunction] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "description").read[String] and
        (__ \ "code").read[String]
      )(ItemFunction.apply _)
    }

    def jsObjectItemFunction(obj: io.flow.catalog.v0.models.ItemFunction): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "description" -> play.api.libs.json.JsString(obj.description),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonReadsCatalogItemFunctionPostForm: play.api.libs.json.Reads[ItemFunctionPostForm] = {
      (
        (__ \ "description").read[String] and
        (__ \ "code").read[String] and
        (__ \ "key").readNullable[String]
      )(ItemFunctionPostForm.apply _)
    }

    def jsObjectItemFunctionPostForm(obj: io.flow.catalog.v0.models.ItemFunctionPostForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.JsString(obj.description),
        "code" -> play.api.libs.json.JsString(obj.code)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesCatalogItemFunctionPostForm: play.api.libs.json.Writes[ItemFunctionPostForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemFunctionPostForm] {
        def writes(obj: io.flow.catalog.v0.models.ItemFunctionPostForm) = {
          jsObjectItemFunctionPostForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemFunctionPutForm: play.api.libs.json.Reads[ItemFunctionPutForm] = {
      (
        (__ \ "description").read[String] and
        (__ \ "code").read[String]
      )(ItemFunctionPutForm.apply _)
    }

    def jsObjectItemFunctionPutForm(obj: io.flow.catalog.v0.models.ItemFunctionPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.JsString(obj.description),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesCatalogItemFunctionPutForm: play.api.libs.json.Writes[ItemFunctionPutForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemFunctionPutForm] {
        def writes(obj: io.flow.catalog.v0.models.ItemFunctionPutForm) = {
          jsObjectItemFunctionPutForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemFunctionReference: play.api.libs.json.Reads[ItemFunctionReference] = {
      (__ \ "id").read[String].map { x => new ItemFunctionReference(id = x) }
    }

    def jsObjectItemFunctionReference(obj: io.flow.catalog.v0.models.ItemFunctionReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsCatalogItemFunctionVersion: play.api.libs.json.Reads[ItemFunctionVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "item_function").read[io.flow.catalog.v0.models.ItemFunction]
      )(ItemFunctionVersion.apply _)
    }

    def jsObjectItemFunctionVersion(obj: io.flow.catalog.v0.models.ItemFunctionVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item_function" -> jsObjectItemFunction(obj.itemFunction)
      )
    }

    implicit def jsonWritesCatalogItemFunctionVersion: play.api.libs.json.Writes[ItemFunctionVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemFunctionVersion] {
        def writes(obj: io.flow.catalog.v0.models.ItemFunctionVersion) = {
          jsObjectItemFunctionVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemStatistics: play.api.libs.json.Reads[ItemStatistics] = {
      (
        (__ \ "items").read[Long] and
        (__ \ "categories").read[Long]
      )(ItemStatistics.apply _)
    }

    def jsObjectItemStatistics(obj: io.flow.catalog.v0.models.ItemStatistics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.JsNumber(obj.items),
        "categories" -> play.api.libs.json.JsNumber(obj.categories)
      )
    }

    implicit def jsonWritesCatalogItemStatistics: play.api.libs.json.Writes[ItemStatistics] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemStatistics] {
        def writes(obj: io.flow.catalog.v0.models.ItemStatistics) = {
          jsObjectItemStatistics(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemVersion: play.api.libs.json.Reads[ItemVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "item").read[io.flow.catalog.v0.models.Item]
      )(ItemVersion.apply _)
    }

    def jsObjectItemVersion(obj: io.flow.catalog.v0.models.ItemVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item" -> jsObjectItem(obj.item)
      )
    }

    implicit def jsonWritesCatalogItemVersion: play.api.libs.json.Writes[ItemVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemVersion] {
        def writes(obj: io.flow.catalog.v0.models.ItemVersion) = {
          jsObjectItemVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocal: play.api.libs.json.Reads[Local] = {
      (
        (__ \ "experience").read[io.flow.common.v0.models.ExperienceSummary] and
        (__ \ "prices").read[Seq[io.flow.catalog.v0.models.LocalizedPrice]] and
        (__ \ "rates").read[Seq[io.flow.currency.v0.models.Rate]] and
        (__ \ "spot_rates").read[Seq[_root_.play.api.libs.json.JsObject]] and
        (__ \ "status").read[io.flow.catalog.v0.models.SubcatalogItemStatus] and
        (__ \ "attributes").readNullable[Map[String, String]] and
        (__ \ "price_attributes").readNullable[Map[String, io.flow.common.v0.models.PriceWithBase]]
      )(Local.apply _)
    }

    def jsObjectLocal(obj: io.flow.catalog.v0.models.Local): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "experience" -> io.flow.common.v0.models.json.jsObjectExperienceSummary(obj.experience),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "rates" -> play.api.libs.json.Json.toJson(obj.rates),
        "spot_rates" -> play.api.libs.json.Json.toJson(obj.spotRates),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.priceAttributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price_attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogLocal: play.api.libs.json.Writes[Local] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Local] {
        def writes(obj: io.flow.catalog.v0.models.Local) = {
          jsObjectLocal(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocalizedAdjustment: play.api.libs.json.Reads[LocalizedAdjustment] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "amount").read[Double] and
        (__ \ "label").read[String] and
        (__ \ "base").read[io.flow.common.v0.models.Price] and
        (__ \ "reason").read[io.flow.catalog.v0.models.AdjustmentReason]
      )(LocalizedAdjustment.apply _)
    }

    def jsObjectLocalizedAdjustment(obj: io.flow.catalog.v0.models.LocalizedAdjustment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base),
        "reason" -> jsObjectAdjustmentReason(obj.reason)
      )
    }

    implicit def jsonWritesCatalogLocalizedAdjustment: play.api.libs.json.Writes[LocalizedAdjustment] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.LocalizedAdjustment] {
        def writes(obj: io.flow.catalog.v0.models.LocalizedAdjustment) = {
          jsObjectLocalizedAdjustment(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocalizedItemDuty: play.api.libs.json.Reads[LocalizedItemDuty] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "amount").read[Double] and
        (__ \ "label").read[String] and
        (__ \ "base").read[io.flow.common.v0.models.Price] and
        (__ \ "adjustment").readNullable[io.flow.catalog.v0.models.LocalizedAdjustment]
      )(LocalizedItemDuty.apply _)
    }

    def jsObjectLocalizedItemDuty(obj: io.flow.catalog.v0.models.LocalizedItemDuty): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      ) ++ (obj.adjustment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjustment" -> jsObjectLocalizedAdjustment(x))
      })
    }

    implicit def jsonReadsCatalogLocalizedItemPrice: play.api.libs.json.Reads[LocalizedItemPrice] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "amount").read[Double] and
        (__ \ "label").read[String] and
        (__ \ "base").read[io.flow.common.v0.models.Price] and
        (__ \ "includes").readNullable[io.flow.catalog.v0.models.IncludedLevies]
      )(LocalizedItemPrice.apply _)
    }

    def jsObjectLocalizedItemPrice(obj: io.flow.catalog.v0.models.LocalizedItemPrice): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      ) ++ (obj.includes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("includes" -> jsObjectIncludedLevies(x))
      })
    }

    implicit def jsonReadsCatalogLocalizedItemVat: play.api.libs.json.Reads[LocalizedItemVat] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "amount").read[Double] and
        (__ \ "label").read[String] and
        (__ \ "base").read[io.flow.common.v0.models.Price] and
        (__ \ "name").read[String] and
        (__ \ "adjustment").readNullable[io.flow.catalog.v0.models.LocalizedAdjustment]
      )(LocalizedItemVat.apply _)
    }

    def jsObjectLocalizedItemVat(obj: io.flow.catalog.v0.models.LocalizedItemVat): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.adjustment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjustment" -> jsObjectLocalizedAdjustment(x))
      })
    }

    implicit def jsonReadsCatalogLocalizedTotal: play.api.libs.json.Reads[LocalizedTotal] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "amount").read[Double] and
        (__ \ "label").read[String] and
        (__ \ "base").read[io.flow.common.v0.models.Price]
      )(LocalizedTotal.apply _)
    }

    def jsObjectLocalizedTotal(obj: io.flow.catalog.v0.models.LocalizedTotal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      )
    }

    implicit def jsonReadsCatalogOptions: play.api.libs.json.Reads[Options] = {
      (
        (__ \ "required").read[Boolean] and
        (__ \ "show_in_catalog").read[Boolean] and
        (__ \ "show_in_harmonization").read[Boolean]
      )(Options.apply _)
    }

    def jsObjectOptions(obj: io.flow.catalog.v0.models.Options): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "required" -> play.api.libs.json.JsBoolean(obj.required),
        "show_in_catalog" -> play.api.libs.json.JsBoolean(obj.showInCatalog),
        "show_in_harmonization" -> play.api.libs.json.JsBoolean(obj.showInHarmonization)
      )
    }

    implicit def jsonWritesCatalogOptions: play.api.libs.json.Writes[Options] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Options] {
        def writes(obj: io.flow.catalog.v0.models.Options) = {
          jsObjectOptions(obj)
        }
      }
    }

    implicit def jsonReadsCatalogQuery: play.api.libs.json.Reads[Query] = {
      (
        (__ \ "id").read[String] and
        (__ \ "q").read[String] and
        (__ \ "type").read[io.flow.catalog.v0.models.QueryType]
      )(Query.apply _)
    }

    def jsObjectQuery(obj: io.flow.catalog.v0.models.Query): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "q" -> play.api.libs.json.JsString(obj.q),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesCatalogQuery: play.api.libs.json.Writes[Query] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Query] {
        def writes(obj: io.flow.catalog.v0.models.Query) = {
          jsObjectQuery(obj)
        }
      }
    }

    implicit def jsonReadsCatalogQueryForm: play.api.libs.json.Reads[QueryForm] = {
      (
        (__ \ "q").read[String] and
        (__ \ "type").read[io.flow.catalog.v0.models.QueryType]
      )(QueryForm.apply _)
    }

    def jsObjectQueryForm(obj: io.flow.catalog.v0.models.QueryForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "q" -> play.api.libs.json.JsString(obj.q),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesCatalogQueryForm: play.api.libs.json.Writes[QueryForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.QueryForm] {
        def writes(obj: io.flow.catalog.v0.models.QueryForm) = {
          jsObjectQueryForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogQueryValidation: play.api.libs.json.Reads[QueryValidation] = {
      (
        (__ \ "valid").read[Seq[String]] and
        (__ \ "invalid").read[Seq[String]]
      )(QueryValidation.apply _)
    }

    def jsObjectQueryValidation(obj: io.flow.catalog.v0.models.QueryValidation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "valid" -> play.api.libs.json.Json.toJson(obj.valid),
        "invalid" -> play.api.libs.json.Json.toJson(obj.invalid)
      )
    }

    implicit def jsonWritesCatalogQueryValidation: play.api.libs.json.Writes[QueryValidation] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.QueryValidation] {
        def writes(obj: io.flow.catalog.v0.models.QueryValidation) = {
          jsObjectQueryValidation(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalog: play.api.libs.json.Reads[Subcatalog] = {
      (
        (__ \ "id").read[String] and
        (__ \ "catalog").read[io.flow.catalog.v0.models.Catalog] and
        (__ \ "settings").read[io.flow.catalog.v0.models.SubcatalogSettings]
      )(Subcatalog.apply _)
    }

    def jsObjectSubcatalog(obj: io.flow.catalog.v0.models.Subcatalog): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "catalog" -> jsObjectCatalog(obj.catalog),
        "settings" -> jsObjectSubcatalogSettings(obj.settings)
      )
    }

    implicit def jsonReadsCatalogSubcatalogForm: play.api.libs.json.Reads[SubcatalogForm] = {
      (__ \ "settings").readNullable[io.flow.catalog.v0.models.SubcatalogSettingsForm].map { x => new SubcatalogForm(settings = x) }
    }

    def jsObjectSubcatalogForm(obj: io.flow.catalog.v0.models.SubcatalogForm): play.api.libs.json.JsObject = {
      (obj.settings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("settings" -> jsObjectSubcatalogSettingsForm(x))
      })
    }

    implicit def jsonWritesCatalogSubcatalogForm: play.api.libs.json.Writes[SubcatalogForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogForm] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogForm) = {
          jsObjectSubcatalogForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogFunction: play.api.libs.json.Reads[SubcatalogFunction] = {
      (
        (__ \ "id").read[String] and
        (__ \ "item_function").read[io.flow.catalog.v0.models.ItemFunction] and
        (__ \ "q").read[String] and
        (__ \ "position").read[Long]
      )(SubcatalogFunction.apply _)
    }

    def jsObjectSubcatalogFunction(obj: io.flow.catalog.v0.models.SubcatalogFunction): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item_function" -> jsObjectItemFunction(obj.itemFunction),
        "q" -> play.api.libs.json.JsString(obj.q),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesCatalogSubcatalogFunction: play.api.libs.json.Writes[SubcatalogFunction] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogFunction] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogFunction) = {
          jsObjectSubcatalogFunction(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogFunctionForm: play.api.libs.json.Reads[SubcatalogFunctionForm] = {
      (
        (__ \ "item_function_id").read[String] and
        (__ \ "q").readNullable[String] and
        (__ \ "position").readNullable[Long]
      )(SubcatalogFunctionForm.apply _)
    }

    def jsObjectSubcatalogFunctionForm(obj: io.flow.catalog.v0.models.SubcatalogFunctionForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item_function_id" -> play.api.libs.json.JsString(obj.itemFunctionId)
      ) ++ (obj.q match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("q" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesCatalogSubcatalogFunctionForm: play.api.libs.json.Writes[SubcatalogFunctionForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogFunctionForm] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogFunctionForm) = {
          jsObjectSubcatalogFunctionForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogFunctionVersion: play.api.libs.json.Reads[SubcatalogFunctionVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "subcatalog_function").read[io.flow.catalog.v0.models.SubcatalogFunction]
      )(SubcatalogFunctionVersion.apply _)
    }

    def jsObjectSubcatalogFunctionVersion(obj: io.flow.catalog.v0.models.SubcatalogFunctionVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "subcatalog_function" -> jsObjectSubcatalogFunction(obj.subcatalogFunction)
      )
    }

    implicit def jsonWritesCatalogSubcatalogFunctionVersion: play.api.libs.json.Writes[SubcatalogFunctionVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogFunctionVersion] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogFunctionVersion) = {
          jsObjectSubcatalogFunctionVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogItem: play.api.libs.json.Reads[SubcatalogItem] = {
      (
        (__ \ "id").read[String] and
        (__ \ "item").read[io.flow.catalog.v0.models.Item] and
        (__ \ "status").read[io.flow.catalog.v0.models.SubcatalogItemStatus] and
        (__ \ "item_function").readNullable[io.flow.catalog.v0.models.ExpandableItemFunction]
      )(SubcatalogItem.apply _)
    }

    def jsObjectSubcatalogItem(obj: io.flow.catalog.v0.models.SubcatalogItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectItem(obj.item),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.itemFunction match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("item_function" -> jsObjectExpandableItemFunction(x))
      })
    }

    implicit def jsonWritesCatalogSubcatalogItem: play.api.libs.json.Writes[SubcatalogItem] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogItem] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogItem) = {
          jsObjectSubcatalogItem(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogItemVersion: play.api.libs.json.Reads[SubcatalogItemVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "subcatalog_item").read[io.flow.catalog.v0.models.SubcatalogItem]
      )(SubcatalogItemVersion.apply _)
    }

    def jsObjectSubcatalogItemVersion(obj: io.flow.catalog.v0.models.SubcatalogItemVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "subcatalog_item" -> jsObjectSubcatalogItem(obj.subcatalogItem)
      )
    }

    implicit def jsonWritesCatalogSubcatalogItemVersion: play.api.libs.json.Writes[SubcatalogItemVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogItemVersion] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogItemVersion) = {
          jsObjectSubcatalogItemVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogReference: play.api.libs.json.Reads[SubcatalogReference] = {
      (__ \ "id").read[String].map { x => new SubcatalogReference(id = x) }
    }

    def jsObjectSubcatalogReference(obj: io.flow.catalog.v0.models.SubcatalogReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsCatalogSubcatalogSettings: play.api.libs.json.Reads[SubcatalogSettings] = {
      (__ \ "update_policy").read[io.flow.catalog.v0.models.UpdatePolicy].map { x => new SubcatalogSettings(updatePolicy = x) }
    }

    def jsObjectSubcatalogSettings(obj: io.flow.catalog.v0.models.SubcatalogSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "update_policy" -> play.api.libs.json.JsString(obj.updatePolicy.toString)
      )
    }

    implicit def jsonWritesCatalogSubcatalogSettings: play.api.libs.json.Writes[SubcatalogSettings] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogSettings] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogSettings) = {
          jsObjectSubcatalogSettings(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogSettingsForm: play.api.libs.json.Reads[SubcatalogSettingsForm] = {
      (__ \ "update_policy").readNullable[io.flow.catalog.v0.models.UpdatePolicy].map { x => new SubcatalogSettingsForm(updatePolicy = x) }
    }

    def jsObjectSubcatalogSettingsForm(obj: io.flow.catalog.v0.models.SubcatalogSettingsForm): play.api.libs.json.JsObject = {
      (obj.updatePolicy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("update_policy" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesCatalogSubcatalogSettingsForm: play.api.libs.json.Writes[SubcatalogSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogSettingsForm] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogSettingsForm) = {
          jsObjectSubcatalogSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogStatistics: play.api.libs.json.Reads[SubcatalogStatistics] = {
      (
        (__ \ "excluded").read[io.flow.catalog.v0.models.ItemStatistics] and
        (__ \ "included").read[io.flow.catalog.v0.models.ItemStatistics] and
        (__ \ "restricted").read[io.flow.catalog.v0.models.ItemStatistics] and
        (__ \ "queue").read[io.flow.catalog.v0.models.ItemStatistics] and
        (__ \ "catalog").read[io.flow.catalog.v0.models.CatalogStatistics]
      )(SubcatalogStatistics.apply _)
    }

    def jsObjectSubcatalogStatistics(obj: io.flow.catalog.v0.models.SubcatalogStatistics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "excluded" -> jsObjectItemStatistics(obj.excluded),
        "included" -> jsObjectItemStatistics(obj.included),
        "restricted" -> jsObjectItemStatistics(obj.restricted),
        "queue" -> jsObjectItemStatistics(obj.queue),
        "catalog" -> jsObjectCatalogStatistics(obj.catalog)
      )
    }

    implicit def jsonWritesCatalogSubcatalogStatistics: play.api.libs.json.Writes[SubcatalogStatistics] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogStatistics] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogStatistics) = {
          jsObjectSubcatalogStatistics(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogVersion: play.api.libs.json.Reads[SubcatalogVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "subcatalog").read[io.flow.catalog.v0.models.Subcatalog]
      )(SubcatalogVersion.apply _)
    }

    def jsObjectSubcatalogVersion(obj: io.flow.catalog.v0.models.SubcatalogVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "subcatalog" -> jsObjectSubcatalog(obj.subcatalog)
      )
    }

    implicit def jsonWritesCatalogSubcatalogVersion: play.api.libs.json.Writes[SubcatalogVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogVersion] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogVersion) = {
          jsObjectSubcatalogVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargeting: play.api.libs.json.Reads[Targeting] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "queries").read[Seq[io.flow.catalog.v0.models.TargetingQuery]] and
        (__ \ "catalog").read[io.flow.catalog.v0.models.CatalogReference] and
        (__ \ "subcatalog").readNullable[io.flow.catalog.v0.models.SubcatalogReference]
      )(Targeting.apply _)
    }

    def jsObjectTargeting(obj: io.flow.catalog.v0.models.Targeting): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "queries" -> play.api.libs.json.Json.toJson(obj.queries),
        "catalog" -> jsObjectCatalogReference(obj.catalog)
      ) ++ (obj.subcatalog match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog" -> jsObjectSubcatalogReference(x))
      })
    }

    implicit def jsonWritesCatalogTargeting: play.api.libs.json.Writes[Targeting] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Targeting] {
        def writes(obj: io.flow.catalog.v0.models.Targeting) = {
          jsObjectTargeting(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingForm: play.api.libs.json.Reads[TargetingForm] = {
      (
        (__ \ "key").read[String] and
        (__ \ "queries").read[Seq[io.flow.catalog.v0.models.TargetingQueryForm]] and
        (__ \ "subcatalog_id").readNullable[String]
      )(TargetingForm.apply _)
    }

    def jsObjectTargetingForm(obj: io.flow.catalog.v0.models.TargetingForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "queries" -> play.api.libs.json.Json.toJson(obj.queries)
      ) ++ (obj.subcatalogId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesCatalogTargetingForm: play.api.libs.json.Writes[TargetingForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingForm] {
        def writes(obj: io.flow.catalog.v0.models.TargetingForm) = {
          jsObjectTargetingForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingItem: play.api.libs.json.Reads[TargetingItem] = {
      (
        (__ \ "id").read[String] and
        (__ \ "targeting").read[io.flow.catalog.v0.models.TargetingSummary] and
        (__ \ "item_number").read[String] and
        (__ \ "query").read[io.flow.catalog.v0.models.TargetingQuery]
      )(TargetingItem.apply _)
    }

    def jsObjectTargetingItem(obj: io.flow.catalog.v0.models.TargetingItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "targeting" -> jsObjectTargetingSummary(obj.targeting),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "query" -> jsObjectTargetingQuery(obj.query)
      )
    }

    implicit def jsonWritesCatalogTargetingItem: play.api.libs.json.Writes[TargetingItem] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingItem] {
        def writes(obj: io.flow.catalog.v0.models.TargetingItem) = {
          jsObjectTargetingItem(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingQuery: play.api.libs.json.Reads[TargetingQuery] = {
      (
        (__ \ "id").read[String] and
        (__ \ "q").read[String] and
        (__ \ "outcome_id").read[String] and
        (__ \ "position").read[Long]
      )(TargetingQuery.apply _)
    }

    def jsObjectTargetingQuery(obj: io.flow.catalog.v0.models.TargetingQuery): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "q" -> play.api.libs.json.JsString(obj.q),
        "outcome_id" -> play.api.libs.json.JsString(obj.outcomeId),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesCatalogTargetingQuery: play.api.libs.json.Writes[TargetingQuery] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingQuery] {
        def writes(obj: io.flow.catalog.v0.models.TargetingQuery) = {
          jsObjectTargetingQuery(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingQueryForm: play.api.libs.json.Reads[TargetingQueryForm] = {
      (
        (__ \ "q").read[String] and
        (__ \ "outcome_id").read[String]
      )(TargetingQueryForm.apply _)
    }

    def jsObjectTargetingQueryForm(obj: io.flow.catalog.v0.models.TargetingQueryForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "q" -> play.api.libs.json.JsString(obj.q),
        "outcome_id" -> play.api.libs.json.JsString(obj.outcomeId)
      )
    }

    implicit def jsonWritesCatalogTargetingQueryForm: play.api.libs.json.Writes[TargetingQueryForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingQueryForm] {
        def writes(obj: io.flow.catalog.v0.models.TargetingQueryForm) = {
          jsObjectTargetingQueryForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingSummary: play.api.libs.json.Reads[TargetingSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "catalog").read[io.flow.catalog.v0.models.CatalogReference] and
        (__ \ "subcatalog").readNullable[io.flow.catalog.v0.models.SubcatalogReference]
      )(TargetingSummary.apply _)
    }

    def jsObjectTargetingSummary(obj: io.flow.catalog.v0.models.TargetingSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "catalog" -> jsObjectCatalogReference(obj.catalog)
      ) ++ (obj.subcatalog match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog" -> jsObjectSubcatalogReference(x))
      })
    }

    implicit def jsonWritesCatalogTargetingSummary: play.api.libs.json.Writes[TargetingSummary] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingSummary] {
        def writes(obj: io.flow.catalog.v0.models.TargetingSummary) = {
          jsObjectTargetingSummary(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingVersion: play.api.libs.json.Reads[TargetingVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "targeting").read[io.flow.catalog.v0.models.Targeting]
      )(TargetingVersion.apply _)
    }

    def jsObjectTargetingVersion(obj: io.flow.catalog.v0.models.TargetingVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "targeting" -> jsObjectTargeting(obj.targeting)
      )
    }

    implicit def jsonWritesCatalogTargetingVersion: play.api.libs.json.Writes[TargetingVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingVersion] {
        def writes(obj: io.flow.catalog.v0.models.TargetingVersion) = {
          jsObjectTargetingVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogExpandableItemFunction: play.api.libs.json.Reads[ExpandableItemFunction] = new play.api.libs.json.Reads[ExpandableItemFunction] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableItemFunction] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableItemFunction] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "item_function" => js.validate[io.flow.catalog.v0.models.ItemFunction]
          case "item_function_reference" => js.validate[io.flow.catalog.v0.models.ItemFunctionReference]
          case other => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.ExpandableItemFunctionUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableItemFunction(obj: io.flow.catalog.v0.models.ExpandableItemFunction): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.catalog.v0.models.ItemFunction => jsObjectItemFunction(x) ++ play.api.libs.json.Json.obj("discriminator" -> "item_function")
        case x: io.flow.catalog.v0.models.ItemFunctionReference => jsObjectItemFunctionReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "item_function_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesCatalogExpandableItemFunction: play.api.libs.json.Writes[ExpandableItemFunction] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ExpandableItemFunction] {
        def writes(obj: io.flow.catalog.v0.models.ExpandableItemFunction) = {
          jsObjectExpandableItemFunction(obj)
        }
      }
    }

    implicit def jsonReadsCatalogExpandableSubcatalog: play.api.libs.json.Reads[ExpandableSubcatalog] = new play.api.libs.json.Reads[ExpandableSubcatalog] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableSubcatalog] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableSubcatalog] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "subcatalog" => js.validate[io.flow.catalog.v0.models.Subcatalog]
          case "subcatalog_reference" => js.validate[io.flow.catalog.v0.models.SubcatalogReference]
          case other => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.ExpandableSubcatalogUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableSubcatalog(obj: io.flow.catalog.v0.models.ExpandableSubcatalog): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.catalog.v0.models.Subcatalog => jsObjectSubcatalog(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog")
        case x: io.flow.catalog.v0.models.SubcatalogReference => jsObjectSubcatalogReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesCatalogExpandableSubcatalog: play.api.libs.json.Writes[ExpandableSubcatalog] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ExpandableSubcatalog] {
        def writes(obj: io.flow.catalog.v0.models.ExpandableSubcatalog) = {
          jsObjectExpandableSubcatalog(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocalizedPrice: play.api.libs.json.Reads[LocalizedPrice] = new play.api.libs.json.Reads[LocalizedPrice] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[LocalizedPrice] = {
        (js \ "key").asOpt[String].getOrElse { sys.error("Union[LocalizedPrice] requires a discriminator named 'key' - this field was not found in the Json Value") } match {
          case "localized_item_price" => js.validate[io.flow.catalog.v0.models.LocalizedItemPrice]
          case "localized_item_vat" => js.validate[io.flow.catalog.v0.models.LocalizedItemVat]
          case "localized_item_duty" => js.validate[io.flow.catalog.v0.models.LocalizedItemDuty]
          case "localized_total" => js.validate[io.flow.catalog.v0.models.LocalizedTotal]
          case other => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.LocalizedPriceUndefinedType(other))
        }
      }
    }

    def jsObjectLocalizedPrice(obj: io.flow.catalog.v0.models.LocalizedPrice): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.catalog.v0.models.LocalizedItemPrice => jsObjectLocalizedItemPrice(x) ++ play.api.libs.json.Json.obj("key" -> "localized_item_price")
        case x: io.flow.catalog.v0.models.LocalizedItemVat => jsObjectLocalizedItemVat(x) ++ play.api.libs.json.Json.obj("key" -> "localized_item_vat")
        case x: io.flow.catalog.v0.models.LocalizedItemDuty => jsObjectLocalizedItemDuty(x) ++ play.api.libs.json.Json.obj("key" -> "localized_item_duty")
        case x: io.flow.catalog.v0.models.LocalizedTotal => jsObjectLocalizedTotal(x) ++ play.api.libs.json.Json.obj("key" -> "localized_total")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesCatalogLocalizedPrice: play.api.libs.json.Writes[LocalizedPrice] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.LocalizedPrice] {
        def writes(obj: io.flow.catalog.v0.models.LocalizedPrice) = {
          jsObjectLocalizedPrice(obj)
        }
      }
    }
  }
}

